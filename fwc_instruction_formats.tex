% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\RaggedRight

\chapter{Instruction formats}
\section{Formats and templates}
All instructions use one of the general format templates shown below (the most significant bits are shown to the left). The basic layout of the 32-bit code word is shown in template A. Template B, C and D are derived from template A by replacing 8, 16 or 24 bits, respectively, with immediate data. Double-size and triple-size instructions can be constructed by adding one or two 32-bit words to one of these templates. For example, template A with an extra 32-bit word containing data is called A2. Template E2 is an extension to template A where the second code word contains an extra register field, extra opcode bits, mode bits, option bits, and data.
\vspace{2mm}

Some small, often-used instructions can be coded in a tiny format that uses a half code word. Two such tiny instructions can be packed into a single code word, using template T. An unpaired tiny instruction must be combined with a tiny-size NOP to fill a whole code word.

\begin{longtable}[l]
{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|}
% \caption{Template A. \\ Has three operand registers and a mask register.} 
\endfirsthead
 \label{table:templateA} \\
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 3 & 5 \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & Mask & RT \\
\hline
\multicolumn{10}{|l|}{
Template A. Has three operand registers and a mask register.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{16mm}|}
\endfirsthead
\label{table:templateB}
\endhead
\hline
  Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 
  \multicolumn{2}{|c|}{ 8 } \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & 
  \multicolumn{2}{|c|}{ IM1 } \\
\hline
  \multicolumn{10}{|l|}{
Template B. Has two operand registers and an 8-bit immediate constant.}  \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}p{8mm}p{8mm}|p{8mm}p{8mm}|}
\endfirsthead
\label{table:templateC}
\endhead
\hline
% It was a real mess to make this look nice. I don't know what's happening here
 Bits & 2 & 3 & 6 & 5 & & \hspace{2mm} 8 & & \multicolumn{2}{|p{20mm}|}{ \hspace{8mm} 8 } \\
\hline
Field & IL & Mode & OP1 & RD & 
\multicolumn{3}{|c|}{ IM2 } & \multicolumn{2}{|c|}{ IM1 } \\
\hline
\multicolumn{10}{|l|}{
Template C. Has one operand register two 8-bit immediate constants.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{40mm}|}
\endfirsthead
\label{table:templateD}
\endhead
\hline
 Bits & 2 & 3 & 3 & 
\multicolumn{1}{|p{69mm}|}{ \hspace{31mm} 24 } \\
\hline
Field & IL & Mode & OP1 & 
\multicolumn{1}{|c|}{ IM2 } \\
\hline
\multicolumn{5}{|l|}{
Template D. Has no register and a 24-bit immediate constant.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|}
\endfirsthead
\label{table:templateE2}
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 3 & 5 \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & Mask & RT \\
\hline
Field & OP2 & \small Mode2 & IM3 & RU & \multicolumn{5}{|c|}{ IM2 } \\
\hline
\multicolumn{10}{|p{108mm}|}{
Template E2. Has 4 register operands, mask, a 16-bit immediate constant and extra bits for
opcode, mode, and options.} \\
\hline
\end{longtable}


\pagebreak
\begin{longtable}[l]{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|}
\endfirsthead
\label{table:templateA2}
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 3 & 5 \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & Mask & RT \\
\hline
Field & \multicolumn{9}{|c|}{ IM2 } \\
\hline
\multicolumn{10}{|l|}{
Template A2. 2 words. As A, with an extra 32-bit immediate constant.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|}
\endfirsthead
\label{table:templateA3}
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 3 & 5 \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & Mask & RT \\
\hline
Field & \multicolumn{9}{|c|}{ IM2 } \\
\hline
Field & \multicolumn{9}{|c|}{ IM3 } \\
\hline
\multicolumn{10}{|l|}{
Template A3. 3 words. As A, with two extra 32-bit immediate constants.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{16mm}|}
\endfirsthead
\label{table:templateB2}
\endhead
\hline
  Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & \multicolumn{2}{|c|}{ 8 } \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & \multicolumn{2}{|c|}{ IM1 } \\
\hline
Field & \multicolumn{9}{|c|}{ IM2 } \\   
\hline
  \multicolumn{10}{|p{108mm}|}{
Template B2. As B, with an extra 32-bit immediate constant.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{16mm}|}
\endfirsthead
\label{table:templateB3}
\endhead
\hline
  Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & \multicolumn{2}{|c|}{ 8 } \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & \multicolumn{2}{|c|}{ IM1 } \\
\hline
Field & \multicolumn{9}{|c|}{ IM2 } \\   
\hline
Field & \multicolumn{9}{|c|}{ IM3 } \\   
\hline
  \multicolumn{10}{|p{108mm}|}{
Template B3. As B, with two extra 32-bit immediate constants.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{20mm}|p{20mm}|}
\endfirsthead
\label{table:templateC2}
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 8 & 8 \\
\hline
Field & IL & Mode & OP1 & RD & IM2 & IM1 \\
\hline
Field & \multicolumn{6}{|c|}{ IM3 } \\   
\hline
\multicolumn{7}{|p{108mm}|}{
Template C2. As C, with an extra 32-bit immediate constant.} \\
\hline
\end{longtable}


\begin{longtable}[l]{|p{8mm}|p{8mm}|p{40mm}|p{40mm}|}
\endfirsthead
\label{table:templateT}
\endhead
\hline
 Bits & 4 & \hspace{16mm} 14 & \hspace{16mm} 14 \\
\hline
Field & 0111 & \hspace{5mm} Tiny instruction 2 & \hspace{5mm} Tiny instruction 1 \\
\hline
\multicolumn{4}{|p{108mm}|}{
Template T. 1 word containing two tiny instructions.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{10mm}|p{15mm}|p{15mm}|p{15mm}|}
\endfirsthead
\label{table:tinyFormat}
\endhead
\hline
Bits & 5 & 5 & 4 \\
\hline
Field & OP1 & RD & RS \\
\hline
\multicolumn{4}{|l|}{
Format for each tiny instruction } \\
\hline
\end{longtable}
\vspace{2mm}


The meaning of each field is described in the following table.

\begin{longtable} {|p{16mm}|p{16mm}|p{85mm}|}
\caption{Fields in instruction templates} \label{table:fieldsInTemplates} \\
\endfirsthead
\endhead
\hline
Field name & Meaning & Values  \\
\hline
IL & Instruction length & 0 or 1: 1 word = 32 bits \newline
2: 2 words = 64 bits \newline
3: 3 or more words  \\
\hline
Mode & Format & Determines the format template and the use of each field. 
Extended with the M bit when needed. \newline 
See details below. \\
\hline
Mode2 & Format & Extension to Mode. \\
\hline
OT & Operand type and size (OS) & 
0: 8 bit integer, OS = 1 byte  \newline
1: 16 bit integer, OS = 2 bytes \newline
2: 32 bit integer, OS = 4 bytes \newline
3: 64 bit integer, OS = 8 bytes \newline
4: 128 bit integer, OS = 16 bytes (optional) \newline
5: single precision float, OS = 4 bytes \newline
6: double precision float, OS = 8 bytes \newline
7: quadruple precision float, OS = 16 bytes (optional) \newline
The OT field is extended with the M bit when needed. \\
\hline
M & Operand type or mode & Extends the mode field when bit 1 and bit 2 of Mode are both zero (general purpose registers). Extends the OT field otherwise (vector registers).  \\
\hline
OP1 & Opcode & Decides the operation, for example add or move.  \\
\hline
OP2 & Opcode & Opcode extension for single-format instructions. \\
\hline
RD & Destination register & r0 – r31 or v0 – v31. Also used for first source operand if the instruction format does not specify enough operands. \\
\hline
RS & Source register & r0 – r31 or v0 – v31. Source register, pointer, index, fallback, or vector length register. \\
\hline
RT & Source register & r0 – r31 or v0 – v31. Source register or pointer.  \\
\hline
RU & Source register & r0 – r31 or v0 – v31. Source register or fallback. \\
\hline
Mask & mask register & 0-6 means that a general purpose register or vector register is used for mask and option bits. 7 means no mask.  \\
\hline
IM1, IM2, IM3 & Immediate data & 8, 16, or 32 bits immediate operand or address offset or option bits. Adjacent IM fields can be merged to make a larger constant. \\
\hline
\end{longtable}
\vspace{2mm}

Instructions have several different formats, defined by the IL and mode bits, according to the table below.\\
\vspace{2mm}

The indicated coding of operands is interpreted in the following way: \\
RD = f2(RS,RT)  means that instructions with two input operands (f2) use the register specified in RD as destination operand and RS and RT as source operands.\\
RD=f3(RD, RU, [RT+RS*OS+IM2])  means that instructions with three input operands (f3) use the register specified in RD as both destination and the first source operand. The second source operand is RU. The third source operand is a memory operand with RT as base pointer, RS as index scaled by the operand size, and the constant IM2 as offset.\\
Instructions with only one input operand are coded as f2 with the first source operand unused.

\begin{longtable} {|p{10mm}|p{6mm}|p{9mm}|p{7mm}|p{80mm}|}
\caption{List of instruction formats} \label{table:instructionFormats} \\
\endfirsthead
\endhead
\hline
Format name & IL & Mode. \small Mode2 & Tem-plate & Use \\
\hline
0.0 & 0 & 0 & A & Three general purpose register operands.\newline 
RD = f2(RS, RT). RD = f3(RD, RS, RT).\newline 
Fallback=RS.\\

\hline
0.1 & 0 & 1 & B & Two general purpose registers and 8-bit immediate operand. \newline
RD = f2(RS, IM1). RD = f3(RD, RS, IM1).\\

\hline
0.2 & 0 & 2 & A & Three vector register operands.\newline 
RD = f2(RS, RT). RD = f3(RD, RS, RT).\newline 
Fallback=RS.\\

\hline
0.3 & 0 & 3 & B & Two vector registers and a broadcast 8-bit immediate operand. \newline
RD = f2(RS, IM1). RD = f3(RD, RS, IM1).\\

\hline
0.4 & 0 & 4 & A & One vector register and memory operand. Vector length specified by general purpose register. \newline
RD = f2(RD, [RT]). length=RS.\\

\hline
0.5 & 0 & 5 & A & One vector register and a memory operand with base pointer and negative index.  This is used for vector loops as explained on page \pageref{vectorLoops}. \newline
RD = f2(RD, [RT-RS]). length=RS.\\

\hline
0.6 & 0 & 6 & A & One vector register and a scalar memory operand with base pointer and scaled index. \newline
RD = f2(RD, [RT+RS*OS]).\\

\hline
0.7 & 0 & 7 & B & One vector register and a scalar memory operand with base pointer and 8-bit offset. \newline
RD = f2(RD, [RS+IM1*OS]).\\

\hline
0.8 & 0 & 0 M=1 & A & One general purpose register and a memory operand with base pointer and scaled index. \newline
RD = f2(RD, [RT+RS*OS]).\\

\hline
0.9 & 0 & 1 M=1 & B & One general purpose register and a memory operand with base pointer and 8-bit offset. \newline
RD = f2(RD, [RS+IM1*OS]).\\

\hline
1.0 & 1 & 0 & A & Single-format instructions. Three general purpose register operands. \newline 
RD = f2(RS, RT). RD = f3(RD, RS, RT).\newline 
Fallback=RS.\\

\hline
1.1 & 1 & 1 & C & Single-format instructions. One general purpose register and a 16-bit immediate operand. \newline 
RD = f2(RD, IM1-2).\\

\hline
1.2 & 1 & 2 & A & Single-format instructions. Three vector register operands. \newline 
RD = f2(RS, RT). RD = f3(RD, RS, RT).\newline 
Fallback=RS.\\

\hline
1.3B & 1 & 3 & B & Single-format instructions. Two vector registers and a broadcast 8-bit immediate operand. \newline 
RD = f2(RS, IM1). RD = f3(RD, RS, IM1). \\

\hline
1.3C & 1 & 3 & C & Single-format instructions. One vector register and a broadcast 16-bit immediate operand. \newline 
RD = f2(RD, IM1-2). \\

\hline
1.4 & 1 & 4 & B & Jump instructions with two register operands and 8 bit offset.\\

\hline
1.5C & 1 & 5 & C & Jump instructions with one register operand, 8 bit constant (IM2) and 8 bit offset (IM1).\\

\hline
1.5D & 1 & 5 & D & Jump instructions with no register and 24 bit offset.  \\

\hline
T & 1 & 6-7 & T & Two tiny instructions.\\

\hline
1.8 & 1 & 0 M=1 & B & Single-format instructions. Two general purpose registers and an 8-bit immediate operand.\newline 
RD = f2(RS, IM1). RD = f3(RD, RS, IM1).\\

\hline
1.9 &  &  &  & There is no format 1.9 because 1.1 has no M bit.\\

\hline
2.0 & 2 & 0 & A2 & Two general purpose registers and a memory operand with base and 32 bit offset (IM2). \newline 
RD = f2(RS, [RT+IM2]). RD = f3(RD, RS, [RT+IM2]).\\

\hline
2.1 & 2 & 1 & A2 & Three general purpose registers and a 32-bit immediate operand.\newline 
RD = f2(RT, IM2). RD = f3(RS, RT, IM2). Fallback=RS.\\

\hline
2.2 & 2 & 2 & A2 & One vector register and a memory operand with base and 32 bit offset.\newline
RD = f2(RD, [RT+IM2]). length=RS.\\

\hline
2.3 & 2 & 3 & A2 & Three vector registers and a broadcast 32-bit immediate operand.\newline 
RD = f2(RT, IM2). RD = f3(RS, RT, IM2). Fallback=RS.\\

\hline
2.4.0 & 2 & 4.0 & E2 & Two vector registers and a broadcast scalar memory operand with base  and 16 bit offset.\newline 
RD = f2(RU, [RT+IM2]). RD = f3(RD, RU, [RT+IM2]). Broadcast to length RS. Fallback=RU.\\

\hline
2.4.1 & 2 & 4.1 & E2 & Two vector registers and a memory operand with base and 16 bit offset.\newline 
RD = f2(RU, [RT+IM2]). RD = f3(RD, RU, [RT+IM2]). Length=RS. Fallback=RU.\\

\hline
2.4.2 & 2 & 4.2 & E2 & Two vector registers and a memory operand with base and negative index. Optional support for a 16-bit offset.\newline 
RD = f2(RU, [RT-RS+IM2]). RD = f3(RD, RU, [RT-RS+IM2]). Length=RS. Fallback=RU. IM2 must be zero if offset not supported.\\

\hline
2.4.3 & 2 & 4.3 & E2 & Two vector registers and a scalar memory operand with base, scaled index, and limit.\newline 
RD = f2(RU, [RT+RS*OS]). RD = f3(RD, RU, [RT+RS*OS]). Limit RS $\leq$ IM2 (unsigned).  Fallback=RU.\\

\hline
2.4.6 & 2 & 4.6 & E2 & Four vector registers.\newline 
RD = f2(RS, RT). RD = f3(RU, RS, RT). Fallback=RU.\\

\hline
2.4.7 & 2 & 4.7 & E2 & Three vector registers and a broadcast immediate half-precision float or 16-bit integer with left shift.\newline 
RD = f2(RS, IM2). RD = f3(RS, RT, IM2). Fallback=RU.\newline
Floating point operands: IM2 is half precision.
Integer operands: IM2 (signed) is shifted left by the 6-bit unsigned value of IM3, or whithout shift if IM3 is used for other purposes. \\

\hline
2.5 & 2 & 5 & A2 & Single-format instructions. Three vector registers and a 32-bit immediate operand.\newline 
RD = f2(RT, IM2). RD = f3(RS, RT, IM2). Fallback=RS.\\

\hline
2.6 & 2 & 6 &  & Currently unused.\\

\hline
2.7 & 2 & 7 & A2, B2, C2 & Jump instructions for OP1 $<$ 8. Single format instruct. with memory operands or mixed register types for OP1 $\geq$ 8.\\

\hline
2.8.0 & 2 & 0.0 M=1 & E2 & Three general purpose registers and a memory operand with base  and 16 bit offset.\newline 
RD = f2(RS, [RT+IM2]). RD = f3(RU, RS, [RT+IM2]). Fallback=RU.\\

\hline
2.8.1 & 2 & 0.1 M=1 & E2 & Two general purpose registers and a memory operand with base and index, no scale. Optional support for a 16 bit offset.\newline 
RD = f2(RU, [RT+RS+IM2]). RD = f3(RD, RU, [RT+RS+IM2]). Fallback=RU. IM2 must be zero if offset not supported.\\

\hline
2.8.2 & 2 & 0.2 M=1 & E2 & Two general purpose registers and a memory operand with base and scaled index. Optional support for a 16 bit offset.\newline 
RD = f2(RU, [RT+RS*OS+IM2]). RD = f3(RD, RU, [RT+RS*OS+IM2]). Fallback=RU. IM2 must be zero if offset not supported.\\

\hline
2.8.3 & 2 & 0.3 M=1 & E2 & Two general purpose registers and a memory operand with base, scaled index, and limit.\newline 
RD = f2(RU, [RT+RS*OS]). RD = f3(RD, RU, [RT+RS*OS]). Limit RS $\leq$ IM2 (unsigned). Fallback=RU.\\

\hline
2.8.6 & 2 & 0.6 M=1 & E2 & Four general purpose registers.\newline 
RD = f2(RS, RT). RD = f3(RU, RS, RT). Fallback=RU.\\

\hline
2.8.7 & 2 & 0.7 M=1 & E2 & Three general purpose registers and a 16-bit integer with left shift.\newline 
RD = f2(RS, IM2). RD = f3(RS, RT, IM2). 
IM2 (signed) is shifted left by the 6-bit unsigned value of IM3, or whithout shift if IM3 is used for other purposes. Fallback=RU. \\

\hline
2.9 & 2 & 1 M=1 & A2 & Single-format instructions. Three general purpose registers and a 32-bit immediate operand.\newline 
RD = f2(RT, IM2). RD = f3(RS, RT, IM2). Fallback=RS.\\

\hline
3.0 & 3 & 0 & B3 & Jump instructions for OP1 $<$ 8. Single format instructions with general purpose registers for OP1 $\geq$ 8. Optional.\\

\hline
3.1 & 3 & 1 & A3 & Three general purpose registers and a 64-bit immediate operand. Optional.\newline 
RD = f2(RT, IM2-3). RD = f3(RS, RT, IM2-3). Fallback=RS.\\

\hline
3.2 & 3 & 2 & A3 & Single-format vector instructions. Optional. \\

\hline
3.3 & 3 & 3 & A3 & Three vector registers and a broadcast 64-bit immediate operand. Optional.\newline 
RD = f2(RT, IM2-3). RD = f3(RS, RT, IM2-3). Fallback=RS.\\

\hline
3.8-3.9 & 3 & 0-1 M=1 & & Currently unused. \\
\hline
4.x & 3 & 4-7 &  & Reserved for future 4-word instructions and longer. \\
\hline
\end{longtable}

\vspace{2mm}
\subsection{Maximum number of input operands}
The hardware supports a maximum of four, or optionally five, input dependencies. The following formats cannot have a mask on three-input instructions (e.g. mul\_add) if the hardware has a limit of four input dependencies: 2.4.0, 2.4.1, 2.4.2, 2.4.3, 2.8.1, 2.8.2, 2.8.3.

\vspace{2mm}
\section{Coding of operands}
\subsection{Operand type}
The type and size of operands is determined by the OT field as indicated above. The operand type is 64 bit integer by default if there is no OT field. The operand size (OS) is the size in bytes of a scalar operand or a vector element. This is equal to the number of bits divided by 8.

\subsection{Register type}
The instructions can use either general purpose registers or vector registers. General purpose registers are used for source and destination operands and for masks if the Mode field is 0 or 1 (with M = 0 or 1). Vector registers are used for source and destination operands and for masks if Mode is 2-7.

\subsection{Pointer register}
Instructions with a memory operand always use an address relative to a base pointer. The base pointer can be a general purpose register, the data section pointer, or the instruction pointer. The pointer is determined by the RS or RT field. This field is interpreted as follows.
\vspace{2mm}

Instruction formats 0.4 - 0.9 can use any of the registers r0-r31 as base pointer. r31 is the stack pointer.
\vspace{2mm}

Instruction formats 2.0, 2.2, 2.4.x, and 2.8.x can use the same registers, except r29 which is replaced by the data section pointer (DATAP), and r30 which is replaced by the instruction pointer (IP).
\vspace{2mm}

Tiny instructions with a memory operand can use r0-r14 or the stack pointer (r31) as pointer in the 4-bit RS field. A value of 15 in the RS field indicates the stack pointer.

\subsection{Index register}
Instruction formats with an index can use r0 - r30 as index. A value of 31 in the index field (RS) means no index. The signed index is multiplied by the operand size (OS) for formats 0.6, 0.8, 2.4.3, 2.8.2, 2.8.3; by 1 for format 2.8.1; or by -1 for format 0.5 and 2.4.2. The result is added to the value of the base pointer.

\subsection{Offsets}
Offsets can be 8, 16 or 32 bits. The value is sign-extended to 64 bits. An 8-bit offset is multiplied by the operand size OS, as given by the OT field. An offset of 16 or 32 bits is not scaled. The result is added to the value of the base pointer.
\vspace{2mm}

Support for addressing modes with both index and offset is optional (format 2.4.2, 2.8.1, 2.8.2). If this kind of addressing involving two additions is not supported then the offset in IM2 must be zero.

\subsection{Limit on index}
Formats 2.4.3 and 2.8.3 have a 16-bit limit on the index register. This is useful for checking array limits. A trap is generated if the value of the index register, interpreted as unsigned, is bigger than the unsigned limit. A negative index will also generate a trap because the negative index will be converted to a very large positive value when interpreted as unsigned.

\subsection{Vector length}
The vector length of memory operands is specified by r0-r30 in the RS field for formats 0.4, 0.5, 2.2, 2.4.0, 2.4.1, 2.4.2. A value of 31 in the RS field indicates a scalar with the same length as the operand size (OS).
\vspace{2mm}

The value of the vector length register gives the vector length of the memory operand in bytes (not the number of elements). If the value is bigger than the maximum vector length then the maximum vector length is used. The value may be zero. The behavior for negative values is implementation dependent: either interpret the value as unsigned or use the absolute value.
\vspace{2mm}

The vector length must be a multiple of the operand size OS, as indicated by the OT field. If the vector length is not a multiple of the operand size then the behavior of the partial vector element is implementation dependent.
\vspace{2mm}

The vector length for source operands in vector registers is included in the register itself.

\subsection{Combining vectors with different lengths}
The vector length of the destination will be the same as the vector length of the first source operand (even if the first source operand uses the RD field).
\vspace{2mm}

A consequence of this is that the length of the result is determined by the order of the operands when two vectors of different lengths are combined.
\vspace{2mm}

If the source operands have different lengths then the lengths will be adjusted as follows. If a vector source operand is too long then the extra elements will be ignored. If a vector source operand is too short then the missing elements will be zero.
\vspace{2mm}

A scalar memory operand (format 0.6 and 0.7) is not broadcast but treated as a short vector. It is padded with zeroes to the vector length of the destination.
\vspace{2mm}

A broadcast memory operand (format 2.4.0) will use the vector length given by the vector length register in the RS field.
\vspace{2mm}

A broadcast immediate operand will use the same vector length as the destination.

\subsection{Immediate constants}
Immediate constants can be 4, 8, 16, 32, and optionally 64 bits. Immediate fields are generally aligned to natural addresses. They are interpreted as follows.
\vspace{2mm}

If OT specifies an integer type then the field is interpreted as an integer. If the field is smaller than the operand size then it is sign-extended to the appropriate size. If the field is larger than the operand size then the superfluous upper bits are ignored. The truncation of a too large immediate operand will not trigger any overflow condition.
\vspace{2mm}

If OT specifies a floating point type then the field is interpreted as follows. Immediate fields of 4 or 8 bits are interpreted as signed integers and converted to floating point numbers of the desired precision. A 16-bit field is interpreted as a half precision floating point number. A 32-bit field is interpreted as a single precision floating point number. It is converted to the desired precision if necessary. A 64-bit field (if supported) is interpreted as a double precision floating point number. A 64-bit field is not allowed with a single precision operand type.
\vspace{2mm}

16-bit immediate constants in format 2.4.7 and 2.8.7 can be shifted left by the 6-bit unsigned value of IM3 to give a 64-bit signed value. Any overflow beyond 64 bits is ignored. No shifting is done if IM3 is used for other purposes.
\vspace{2mm}

An instruction can be made compact by using the smallest immediate field size that fits the actual value of the constant.

\subsection{Mask register and fallback register}
The 3-bit mask field indicates a mask register. Register r0-r6 is used if the destination is a general purpose register. Vector register v0-v6 is used if the destination is a vector register. A value of 7 in the mask field means no mask and unconditional execution using the options specified in the numeric control register.
\vspace{2mm}

If the mask is a vector register then it is interpreted as a vector with the same element size as indicated by the OT field. Each element of the mask register is applied to the corresponding element of the result.
\vspace{2mm}

The mask has multiple purposes. The primary purpose is for conditional execution. An instruction is not executed if bit 0 of the mask is zero. In this case, the destination will get a fallback value instead of the result of the calculation, and any numerical error condition will be suppressed. Vector instructions are executed conditionally for each vector element separately, so that each vector element is enabled if bit 0 of the corresponding vector element of the mask register is one.
\vspace{2mm}

The fallback value may be taken from a separate register. The fallback value is zero if there is no fallback register. Only some of the instruction formats have a fallback register. A value of 31 in the fallback register field means no fallback register, and a fallback value of zero. A consequence of this is that register r31 and v31 cannot be used for fallback values. 
\vspace{2mm}

Some instruction formats use the same register for a source operand and for fallback. The only way to get a fallback value of zero instead of the value of the source operand in these instruction formats is to use register v31.
\vspace{2mm}

The remaining bits of the flag are used for specifying various options.
The meanings of these flag bits are described in the next section.

\section{Coding of masks}
A mask register can be a general purpose register r0-r6 or a vector register v0-v6. A value of 7 in the mask field means no mask.
\vspace{2mm}

The bits in the mask register are coded as follows.

\begin{longtable}
{|p{15mm}|p{90mm}|}
\caption{Bits in mask register and numeric control register}
\label{table:maskBits}
\endfirsthead
\endhead
\hline
\bfseries Bit number & \bfseries Meaning \\
 \hline
0 & Predicate or mask. The operation is executed only if this bit is one, as explained above.\\
\hline
2-5 & Instruction-specific option bits.\\
\hline
6 & Generate a trap if unsigned integer overflow. \\
\hline
7 & Generate a trap if signed integer overflow. \\

\hline
18-19 & Floating point rounding mode: \newline
00 = nearest or even \newline
01 = down \newline
10 = up \newline
11 = towards zero \\
\hline
20 & Support subnormal numbers. Subnormal floating point numbers are treated as zero or flushed to zero when this bit is 0 (this is generally faster). \\
\hline
21 & Better NAN propagation. If this bit is zero then the IEEE Standard 754-2008 (or later) is followed strictly for NAN values. A value of one in bit 21 improves NAN propagation and the use of NANs for tracing floating point errors. The details are described on page \pageref{nanPropagation}. \\
\hline
26 & Generate a trap if floating point overflow or division by zero.  \\
\hline
27 & Generate a trap if floating point invalid operation. \\
\hline
28 & Generate a trap if floating point underflow and precision loss. \\
\hline
29 & Generate a trap if NAN inputs to compare instructions and floating point to integer conversion instructions.\\
\hline
\end{longtable}

Bits 8, 16, 24, etc. in a vector mask register can be used like bit 0 for 8-bit and 16-bit operand sizes. All other bits are reserved for future use.
\vspace{2mm}

Vector instructions treat the mask register as a vector with the same element size (OS) as the operands. Each element of the mask vector has the bit codes as listed above. The different vector elements can have different mask bits.
\vspace{2mm}

The numeric control register (NUMCONTR) is used as mask when the mask field is 7 or absent. The NUMCONTR register is broadcast to all elements of a vector, using as many bits of NUMCONTR as indicated by the operand size, when an instruction has no mask register. 
The same mask is applied to all vector elements in this case. 
Bit 0 in NUMCONTR must be 1.
\vspace{2mm}

The instruction-specific option bits are used for various options in compare, add\_add, mul\_add, and possibly other instructions. The instruction-specific options are determined by IM3 in format 2.4.x and 2.8.x and by the mask register in other formats. The instruction-specific options are zero when there is no IM3 and no mask. Unlike other options, the instruction-specific options are not taken from the numeric control register. The reason for this is that frequent changes of the numeric control register would be inefficient (renaming of the numeric control register may not be supported).


\section{Format for jump, call and branch instructions}
Most branches in ordinary code are based on the result of an arithmetic or logic instruction (ALU). The ForwardCom design combines the ALU instruction and the conditional jump into a single instruction. For example, a loop control can be implemented with a single instruction that counts down and jumps until it reaches zero or counts up through negative values and jumps until it reaches zero.
\vspace{2mm}

The jumps, calls, branches and multiway branches will use the following formats.

\begin{longtable}
{|p{10mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{70mm}|}
\caption{List of formats for control transfer instructions}
\label{table:jumpInstructionFormats}
\endfirsthead
\endhead
\hline
Format & IL & Mode & OP1 & Tem-plate & Description \\
\hline
1.4 & 1 & 4 & OPJ & B & Short version with two register operands (RD, RS) and 8 bit offset  (IM1).  \\
\hline
1.5 C & 1 & 5 & OPJ & C & Short version with one register operand (RD), an 8-bit immediate constant (IM2) and 8 bit offset (IM1), or a 16-bit offset (IM2+IM1 combined). \\
\hline
1.5 D & 1 & 5 & 0-15 & D & Jump or call with 24-bit offset. \\
\hline
2.7.0 & 2 & 7 & 0 & B2 & Double size version with two register operands and 32 bit offset  (IM2). IM1 = OPJ. \\
\hline
2.7.1 & 2 & 7 & 1 & B2 & Double size version with a register destination operand, a register source operand, a 16-bit offset (IM2 lower half) and a 16-bit immediate operand (IM2 upper half).  \\
\hline
2.7.2 & 2 & 7 & 2 & C2 & Double size version with one register operand (RD), one 8-bit immediate constant (IM2) and 32 bit offset (IM3). \\
\hline
2.7.3 & 2 & 7 & 3 & C2 & Double size version with one register operand (RD), an 8-bit offset (IM2) and a 32-bit immediate constant (IM3).  \\
\hline
2.7.4 & 2 & 7 & 4 & C2 & Double size system call, no OPJ, 16 bit constant (IM1,IM2) and 32-bit constant (IM3). \\
\hline
3.0.0 & 3 & 0 & 0 & C2 & No operation (NOP). \\
\hline
3.0.1 & 3 & 0 & 1 & B3 & Triple size version with a register destination operand, a register source operand, a 32-bit immediate operand (IM2) and a 32-bit offset (IM3). Optional.  \\
\hline
\end{longtable}

The jump, call and branch instructions have signed offsets of 8, 16, 24 or 32 bits relative to the instruction pointer. Or, more precisely, relative to the end of the instruction. This offset is multiplied by the instruction word size (= 4) to cover an address range of $\pm$ a half kilobyte for short conditional jumps with 8 bits offset, $\pm$ 128 kbytes for jumps and calls with 16 bits offset, $\pm$ 32 megabytes for 24 bits offset, and $\pm$ 8 gigabytes for 32 bits offsets. The optional triple-size format includes unconditional jump and call with a 64 bits absolute address.
\vspace{2mm}

The versions with template C and C2 have no OT field. The operand type is 64-bit integer when there is no OT field. It is not possible to use formats with template C or C2 with floating point types. The instructions will use vector registers (first element only) when there is an OT field and M = 1. In other words, the ALU-jump instructions will use vector registers only when a floating point type is specified (or 128-bit integer type, if supported). General purpose registers are used in all other cases. It is possible to use bitwise logical instructions with vector registers by specifying a floating point type. 
\vspace{2mm}

The OPJ field defines the operation and jump condition. This field has 6 bits in the single size version and 8 bits in the longer versions. The two extra bits in the longer versions are used as follows. Bit 6 is reserved for future extensions, and must be zero. Bit 7 may be used for indicating loop behavior as a hint for choosing the optimal branch prediction algorithm.
\vspace{2mm}

The lower 6 bits of the OPJ field contains the following codes.

\begin{longtable}
{|p{10mm}|p{11mm}|p{50mm}|p{35mm}|}
%\nopagebreak
\caption{List of control transfer instructions: jump, call, return}
\label{table:controlTransferInstructions}
\endfirsthead
\endhead
\hline
OPJ & bit 0 \newline of OPJ & Function & Comment \\
\hline
0-7 & part of offset & Unconditional jump with 24-bit offset (jump) & Format 1.5 D \\
\hline
8-15 & part of offset & Unconditional call with 24-bit offset (call) & Format 1.5 D \\
\hline
0-1 & invert & Subtract, jump if not zero (sub, jump\_nzero) & Format 1.4 and 2.7.0. No floating point. \\
\hline
2-3 & invert & Subtract signed, jump if negative (sub, jump\_neg) & Format 1.4 and 
    2.7.0. No floating point. \\
\hline
4-5 & invert & Subtract signed, jump if positive (sub, jump\_pos) & Format 1.4 and 2.7.0.
    No floating point. \\
\hline
6-7 & invert & Subtract signed, jump if overflow (sub, jump\_overfl) & Format 1.4 and 2.7.0. No floating point. \\
\hline
8-9 & invert & Subtract unsigned, jump if borrow (sub, jump\_borrow) & Format 1.4 and 2.7.0. No floating point. \\
\hline
10-11 & invert & Subtract unsigned, jump if not zero or borrow (sub, jump\_nzb) & Format 1.4 and 2.7.0. No floating point. \\
\hline

12-15 & & Reserved for future use & Format 1.4 and 2.7.0. \\
\hline

16-17 & invert & Add, jump if not zero (add, jump\_nzero) & No floating point \\
\hline
18-19 & invert & Add signed, jump if negative (add, jump\_neg) & No floating point. \\
\hline
20-21 & invert & Add signed, jump if positive (add, jump\_pos) & No floating point. \\
\hline
22-23 & invert & Add signed, jump if overflow (add, jump\_overfl) & No floating point  \\
\hline
24-25 & invert & Add unsigned, jump if carry (add, jump\_carry) & No floating point. \\
\hline
24-25 & invert & Jump if either operand is NAN (compare, jump\_unordered) & Floating point operands \\
\hline
26-27 & invert & Add unsigned, jump if not zero or carry (add, jump\_nzc) & No floating point. \\
\hline
26-27 & invert & Jump if either operand is $\pm$ infinite or NAN (compare, jump\_infnan) & Floating point operands \\
\hline

28-29 & invert & Shift left by n, jump if not zero (shift, jump\_nzero) & Shift right unsigned if n negative \\
\hline
30-31 & invert & Shift left by n, jump if carry (shift, jump\_carry) & Shift right unsigned if n negative  \\
\hline
32-33 & invert & Compare, jump if not equal (compare, jump\_nequal) & \\
\hline
34-35 & invert & Compare signed, jump if below (compare, jump\_sbelow) &  \\
\hline
36-37 & invert & Compare signed, jump if above (compare, jump\_sabove) &  \\
\hline
38-39 & invert & Compare unsigned, jump if below (compare, jump\_ubelow) & Integer operands \\
\hline
38-39 & invert & Compare absolute values, jump if below (compare, jump\_absbelow) &  Floating point operands \\
\hline
40-41 & invert & Compare unsigned, jump if above (compare, jump\_uabove) & Integer operands  \\
\hline
40-41 & invert & Compare absolute values, jump if above (compare, jump\_absabove) & Floating point operands \\
\hline
42-43 & invert & Bitwise test, jump if not zero (test, jump\_nzero) &  \\
\hline
44-45 & invert & Bitwise and, jump if not zero (and, jump\_nzero) & \\
\hline
46-47 & invert & Bitwise or, jump if not zero (or, jump\_nzero) &  \\
\hline
48-49 & invert & Bitwise xor, jump if not zero (xor, jump\_nzero) & \\
\hline
50-51 & invert & Test single bit, jump if not zero (testbit, jump\_nzero) & \\
\hline
52-53 & invert & Test single bit on vector register, jump if not zero \newline
 (testbit, jump\_nzero) &  \\
\hline
54-55 & & Reserved for future use. & \\
\hline
56 & 0 & Subtract, jump unconditionally (sub, jump) & \\
\hline
57 & 1 & Add, jump unconditionally (add, jump) & \\
\hline
58-59 & 0 jump \newline 1 call & Indirect jump or call with pointer address in register RS,
pointer offset in IM1 or IM2 (jump/call). & Format 1.4 and 2.7.0. \\
\hline
58-59 & 0 jump \newline 1 call & Unconditional direct jump or call with 16 bit or
32 bit offset or 64-bit absolute address (jump/call) & Format 1.5 C, 2.7.2, and
3.0.1. \\
\hline
60-61 & 0 jump \newline 1 call & Use table of addresses relative to RD. RT = table base, RS = index*OS (jump/call) & Format 1.4,\newline template A. \\
\hline
60-61 & 0 jump \newline 1 call & Unconditional jump or call to value of register RS (jump/ call)  & Format 1.5. \\
\hline
62 & 0 & Return from function (return) & Format 1.4.  \\
\hline
62 & 0 & Return from system function (sys\_return) & Format 1.5.  \\
\hline
63 & 1 & System call. ID in register RT, shared memory block RD, length RS. No mask (sys\_call) & Format 1.4,\newline template A. \\
\hline
63 & 1 & System call. ID in constants, shared memory block RD, length RS (sys\_call) & Format 2.7.1, 2.7.4 and 3.0.1. \\
\hline
63 & 1 & Unconditional trap. Interrupt number in IM1 (trap). & Format 1.5. \\
\hline
63 & 1 & Filler for unused code memory. All fields are all 1's (filler). & Format 1.5. \\
\hline
63 & 1 & Trap if unsigned RD \textgreater{} IM3. IM2 = 40. Interrupt number is fixed  (compare, trap\_uabove). & Format 2.7.3. \\
\hline
\end{longtable}

Signed integer comparisons are corrected for overflow, but signed additions and subtractions are not. For example, if A is a large positive integer and B is a large negative integer then sub\_jump\_neg will jump if the calculation of A-B overflows to give a negative result, but compare\_jump\_sbelow will not jump because A is bigger than B.
\vspace{2mm}

The combined ALU and conditional jump instructions can be coded in the formats 1.4, 1.5 C, 2.7.0, 2.7.1, 2.7.2, 2.7.3, and 3.0.1, except subtraction which cannot be coded in format 1.5 C. Subtraction with an immediate constant can be replaced by addition with the negative constant. The code space that would have been used by subtraction in format 1.5 C is instead used for coding direct jump and call instructions with a 24-bit offset using format 1.5 D, where the lower three bits of OP1 are used as part of the 24-bit offset.
\vspace{2mm}

The add and subtract operations are usually not supported for floating point operands because the longer latencies of these floating point operations will complicate the pipeline design. Floating point compare is supported because it is possible to make a floating point compare operation in a single clock cycle, using unsigned integer compare on the combined exponent and significant with special handling of the sign bit and NAN values.
\vspace{2mm}

The test bit instruction (testbit\_jump\_nzero) will test bit number n in the first operand, where n is the value of the second operand (RS or IM2). This is useful for testing bit fields, sign bits, and the output of compare instructions. The second operand is interpreted as an 8-bit unsigned integer regardless of the operand type.
\vspace{2mm}

The shift left instructions will shift the first operand left when the second operand is positive and shift right with zero extension when the second operand is negative. The carry is the last bit shifted out. The operands are interpreted as integers regardless of the operand type, but vector registers are used if a floating point operand type is specified (M = 1).
\vspace{2mm}

Unconditional and indirect jumps and calls use the formats indicated above, where unused fields must be zero. Bit 0 of the OPJ field is zero for jump instructions and one for call instructions.
\vspace{2mm}

\label{jumpTableInstruction}
The table-based indirect jump/call instructions are intended to facilitate multiway branches (switch/case statements), function tables in code interpreters, and virtual function tables in object oriented languages with polymorphism. The table of jump or call addresses is stored as signed offsets relative to an arbitrary reference point, which may be the table address, the code base, or any other reference point. The operand type specifies the size of the table entries. 16-bit and 32-bit table entries must be supported. Other sizes are optional. The use of relative addresses makes the table more compact than if 64-bit absolute addresses were used. This instruction works as follows. Calculate the address of a table entry as the base pointer (RT) plus the index (RS) multiplied by the operand size. Read a signed value from this address, and scale by 4. Sign-extend this value to 64 bits, and add the reference point (RD). Jump or call to the calculated address. The array index (RS) is scaled by the operand size, while the table entries are scaled by the instruction word size (4). Support for a mask is optional.
\vspace{2mm}

The table used by the table-based jump/call instructions may be placed in the constant data section (CONST). This makes it possible to use the table base as reference point and it improves security by giving read-only access to the table.
\vspace{2mm}

Return instructions do not need a stack offset when the calling conventions specified on page \pageref{functionCallingConventions} are used.
\vspace{2mm}

\label{systemCallInstruction}
System calls use ID numbers rather than addresses to identify system functions. 
The ID is the combination of a module ID identifying a particular system module or device driver and a function ID identifying a particular function within this module. The module ID and the function ID are both 16 or 32 bits, so that the combined system call ID is up to 64 bits.
The sys\_call instruction has the following variants:

\begin{longtable}
{|p{30mm}|p{30mm}|p{30mm}|p{30mm}|}
\caption{Variants of system call instruction}
\label{table:syscallInstructions}
\endfirsthead
\endhead
\hline
Format & Operand type & Function ID & Module ID \\
\hline
1.4 & 32 bit & RT bit 0-15 & RT bit 16-31  \\
\hline
1.4 & 64 bit & RT bit 0-31 & RT bit 32-63  \\
\hline
2.7.1 & 32 bit & IM2 bit 0-15 & IM2 bit 16-31 \\
\hline
2.7.4 & 64 bit & IM1,IM2 bit 0-15 & IM3 bit 0-31 \\
\hline
3.0.1 & 64 bit & IM2 bit 0-31 & IM3 bit 0-31 \\
\hline
\end{longtable}

The sys\_call instruction can indicate a block of memory to be shared with the system function. The address of the memory block is pointed to by the register specified in RD and the length is in register RS. This memory block, which the caller must have access rights to, is shared with the system function. The system function will get the same access rights to this block as the calling thread has, i. e. read access and/or write access. This is useful for fast transfer of data between the caller and the system function. No other memory is accessible to both the caller and the called function. If the RD and RS fields are both zero (i. e. indicating register r0) then no memory block is shared. The sys\_call instruction in format 2.7.4 cannot have a shared memory block.
\vspace{2mm}

Parameters for system functions are transferred in registers, following the same calling conventions as normal functions. The registers used for function parameters are usually different from the registers in the RD, RS and RT fields. Function parameters that do not fit into registers must reside in the shared memory block.
\vspace{2mm}

\label{traps}
Traps work like interrupts. The unconditional trap has an 8-bit interrupt number in IM1. This is an index into the interrupt vector table, which initially starts at absolute address zero. The unconditional trap instruction may use IM2 for additional information. The conditional trap is intended for checking array bounds. The interrupt number is fixed (the value has not been decided yet). The conditional trap may optionally support other condition codes in IM2, using the same codes as OPJ in table \ref{table:controlTransferInstructions}.
\vspace{2mm}

A trap instruction with all 1's in all fields (opcode 0x6FFFFFFF) can be used as filler in unused parts of code memory.

\section{Assignment of opcodes}
The opcodes and formats for new instructions can be assigned according to the following rules.

\begin{itemize}
\item Multi-format instructions. Often-used instructions that need to support many different operand types, addressing modes and formats use all or most of the following formats: 0.0-0.9, 2.0-2.4, 2.8-2.9, and optionally 3.1 and 3.3 if triple-size instructions are supported. The same value of OP1 is used in all these formats. OP2 must be 0. Instructions with few source operands should have the lowest values of OP1.

\item Tiny instructions. Only some of the most common instructions are available in tiny versions, as there is only space for 32 tiny instructions. The instructions are ordered according to the number and type of operands, as shown in table \ref{table:tinyInstructionsGP} page \pageref{table:tinyInstructionsGP}.

\item Control transfer instructions, i. e. jumps, branches, calls and returns, can be coded as short instructions with IL = 1, mode = 4-5, and OP1 = 0-63 or as double-size instructions with IL = 2, mode = 7, OP1 = 0-7, and optionally as triple-size instructions with IL = 3, mode = 0, OP1 = 0-7. See page \pageref{table:jumpInstructionFormats}.

\item Short single-format instructions with general purpose registers. Use mode 1.0, 1.1, and 1.8, with  any value of OP1.

\item Short single-format instructions with vector registers. Use mode 1.2 and 1.3
with any value of OP1.

\item Double-size single-format instructions with general purpose registers can use mode 2.9 with any value of OP1, and mode 2.8.x with any value of OP1 and OP2 $\neq$ 0 (give similar instructions the same value of OP2). If more combinations are needed then use IM3 for further subdivision of the code space.

\item Double-size single-format instructions with vector registers can use mode 2.5 with with any value of OP1, and mode 2.4.x with any value of OP1 and OP2 $\neq$ 0 (give similar instructions the same value of OP2). If more combinations are needed then use IM3 for further subdivision of the code space.

\item Double-size single-format instructions with mixed vector and general purpose registers or with memory operands can use mode 2.7 with OP1 in the range 8-63.

\item Triple-size single-format instructions with general purpose registers can use mode 3.0 with OP1 in the range 8-63.

\item Triple-size single-format instructions with vector registers can use mode 3.2 with any value in OP1.

\item Future instructions longer than three 32-bit words are coded with IL = 3, mode = 4-7.

\item New options or other modifications to existing instructions can use IM3 bits or mask register bits.

\item New addressing modes may be implemented as single-format read and write instructions. New addressing modes or other formats that apply to all multi-format instructions can use unused values of Mode2 with template E2.


\end{itemize}

All unused fields must be zero. The instructions with the fewest input operands should preferably have the lowest OP1 codes. 
\vspace{2mm}

Application-specific instructions should preferably use format 2.4.x and 2.8.x with OP2 $\neq$ 0. There are many vacant opcodes in these formats. General multi-purpose instructions may use some of the more crowded formats.

\end{document}
