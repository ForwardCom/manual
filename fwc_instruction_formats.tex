% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\RaggedRight

\chapter{Instruction formats}
\section{Formats and templates}
All instructions use one of the general format templates shown below (the most significant bits are shown to the left). The basic layout of the 32-bit code word is shown in template A. Template B, C and D are derived from template A by replacing 8, 16 or 24 bits, respectively, with immediate data. Double-size and triple-size instructions can be constructed by adding one or two 32-bit words to one of these templates. For example, template A with an extra 32-bit word containing data is called A2. Template E2 is an extension to template A where the second code word contains an extra register field, extra opcode bits, option bits, and data.
\vspace{2mm}

Some small, often-used instructions can be coded in a tiny format that uses a half code word. Two such tiny instructions can be packed into a single code word, using template T. An unpaired tiny instruction must be combined with a tiny-size NOP to fill a whole code word.

\begin{longtable}[l]
{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|}
% \caption{Template A. \\ Has three operand registers and a mask register.} 
\endfirsthead
 \label{table:templateA} \\
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 3 & 5 \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & Mask & RT \\
\hline
\multicolumn{10}{|l|}{
Template A. Has three operand registers and a mask register.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|}
\endfirsthead
\label{table:templateB}
\endhead
\hline
  Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 
  \multicolumn{2}{|c|}{ 8 } \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & 
  \multicolumn{2}{|c|}{ IM1 } \\
\hline
  \multicolumn{10}{|p{108mm}|}{
Template B. Has two operand registers and an 8-bit immediate constant.}  \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{22mm}|p{22mm}|}
\endfirsthead
\label{table:templateC}
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 
 \hspace{9mm} 8 & \hspace{9mm} 8 \\
\hline
Field & IL & Mode & OP1 & RD & 
%\hspace{8mm} IM2 & \hspace{8mm} IM1  \\
\multicolumn{1}{|c|}{ IM2 } & \multicolumn{1}{|c|}{ IM1 } \\
\hline
\multicolumn{7}{|p{108mm}|}{
Template C. Has one operand register two 8-bit immediate constants.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{52mm}|}
\endfirsthead
\label{table:templateD}
\endhead
\hline
 Bits & 2 & 3 & 3 & 
\multicolumn{1}{|c|}{ 24 } \\
\hline
Field & IL & Mode & OP1 & 
\multicolumn{1}{|c|}{ IM2 } \\
\hline
\multicolumn{5}{|p{108mm}|}{
Template D. Has no register and a 24-bit immediate constant.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|}
\endfirsthead
\label{table:templateE2}
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 3 & 5 \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & Mask & RT \\
\hline
Field & \multicolumn{2}{|c|}{ OP2 } & OP3 & RU & \multicolumn{5}{|c|}{ IM2 } \\
\hline
\multicolumn{10}{|p{108mm}|}{
Template E2. Has 4 register operands, mask, a 16-bit immediate constant and extra bits for
opcode or options.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|}
\endfirsthead
\label{table:templateA2}
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 3 & 5 \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & Mask & RT \\
\hline
Field & \multicolumn{9}{|c|}{ IM2 } \\
\hline
\multicolumn{10}{|l|}{
Template A2. 2 words. As A, with an extra 32-bit immediate constant.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|}
\endfirsthead
\label{table:templateA3}
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & 3 & 5 \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & Mask & RT \\
\hline
Field & \multicolumn{9}{|c|}{ IM2 } \\
\hline
Field & \multicolumn{9}{|c|}{ IM3 } \\
\hline
\multicolumn{10}{|l|}{
Template A3. 3 words. As A, with two extra 32-bit immediate constants.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|}
\endfirsthead
\label{table:templateB2}
\endhead
\hline
  Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & \multicolumn{2}{|c|}{ 8 } \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & \multicolumn{2}{|c|}{ IM1 } \\
\hline
Field & \multicolumn{9}{|c|}{ IM2 } \\   
\hline
  \multicolumn{10}{|p{108mm}|}{
Template B2. As B, with an extra 32-bit immediate constant.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|}
\endfirsthead
\label{table:templateB3}
\endhead
\hline
  Bits & 2 & 3 & 6 & 5 & 1 & 2 & 5 & \multicolumn{2}{|c|}{ 8 } \\
\hline
Field & IL & Mode & OP1 & RD & M & OT & RS & \multicolumn{2}{|c|}{ IM1 } \\
\hline
Field & \multicolumn{9}{|c|}{ IM2 } \\   
\hline
Field & \multicolumn{9}{|c|}{ IM3 } \\   
\hline
  \multicolumn{10}{|p{108mm}|}{
Template B3. As B, with two extra 32-bit immediate constants.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{7mm}|p{22mm}|p{22mm}|}
\endfirsthead
\label{table:templateC2}
\endhead
\hline
 Bits & 2 & 3 & 6 & 5 & 8 & 8 \\
\hline
Field & IL & Mode & OP1 & RD & IM2 & IM1 \\
\hline
Field & \multicolumn{6}{|c|}{ IM3 } \\   
\hline
\multicolumn{7}{|p{108mm}|}{
Template C2. As C, with an extra 32-bit immediate constant.} \\
\hline
\end{longtable}


\begin{longtable}[l]{|p{7mm}|p{7mm}|p{40mm}|p{40mm}|}
\endfirsthead
\label{table:templateT}
\endhead
\hline
 Bits & 4 & \hspace{16mm} 14 & \hspace{16mm} 14 \\
\hline
Field & 0111 & \hspace{5mm} Tiny instruction 2 & \hspace{5mm} Tiny instruction 1 \\
\hline
\multicolumn{4}{|p{108mm}|}{
Template T. 1 word containing two tiny instructions.} \\
\hline
\end{longtable}

\begin{longtable}[l]{|p{10mm}|p{15mm}|p{15mm}|p{15mm}|}
\endfirsthead
\label{table:tinyFormat}
\endhead
\hline
Bits & 5 & 5 & 4 \\
\hline
Field & OP1 & RD & RS \\
\hline
\multicolumn{4}{|l|}{
Format for each tiny instruction } \\
\hline
\end{longtable}
\vspace{2mm}


The meaning of each field is described in the following table.

\begin{longtable} {|p{16mm}|p{16mm}|p{85mm}|}
\caption{Fields in instruction templates} \label{table:fieldsInTemplates} \\
\endfirsthead
\endhead
\hline
Field name & Meaning & Values  \\
\hline
IL & Instruction length & 0 or 1: 1 word = 32 bits \newline
2: 2 words = 64 bits \newline
3: 3 or more words  \\
\hline
Mode & Format & Determines the format template and the use of each field. 
Extended with the M bit when needed. \newline 
See details below. \\
\hline
OP1 & Opcode & Decides the operation, for example add or move.  \\
\hline
OT & Operand type and size (OS) & 
0: 8 bit integer, OS = 1 byte  \newline
1: 16 bit integer, OS = 2 bytes \newline
2: 32 bit integer, OS = 4 bytes \newline
3: 64 bit integer, OS = 8 bytes \newline
4: 128 bit integer, OS = 16 bytes (optional) \newline
5: single precision float, OS = 4 bytes \newline
6: double precision float, OS = 8 bytes \newline
7: quadruple precision float, OS = 16 bytes (optional) \newline
The OT field is extended with the M bit when needed. \\
\hline
RD & Destination register & r0 – r31 or v0 – v31. Also used for first source operand if the instruction format does not specify enough operands. \\
\hline
RS & Source register & r0 – r31 or v0 – v31. Source register, pointer, index or vector length register. \\
\hline
RT & Source register & r0 – r31 or v0 – v31. Source register or pointer.  \\
\hline
RU & Source register & r0 – r31 or v0 – v31. Source register. \\
\hline
Mask & mask register & 0 means no mask. 1-7 means that a general purpose register or vector register is used for mask and option bits.  \\
\hline
M & Operand type or mode & Extends the mode field when bit 1 and bit 2 of Mode are both zero (general purpose registers). Extends the OT field otherwise (vector registers).  \\
\hline
OP2 & Opcode & Opcode extension. \\
\hline
IM1, IM2, IM3 & Immediate data & 8, 16, 32 or 64 bits immediate operand or address offset or option bits. Adjacent IM fields can be merged. \\
\hline
OP3 & Options & Option bits, mode bits, or immediate data. \\
\hline
\end{longtable}
\vspace{2mm}

Instructions have several different formats, defined by the IL and mode bits, according to the
following table

\begin{longtable} {|p{10mm}|p{7mm}|p{7mm}|p{7mm}|p{80mm}|}
\caption{List of instruction formats} \label{table:instructionFormats} \\
\endfirsthead
\endhead
\hline
Format name & IL & Mode & Tem-plate & Use  \\
\hline
0.0 & 0 & 0 & A & Three general purpose register operands (RD, RS, RT).  \\
\hline
0.1 & 0 & 1 & B & Two general purpose registers (RD, RS) and an 8-bit immediate operand (IM1). \\
\hline
0.2 & 0 & 2 & A & Three vector register operands (RD, RS, RT). \\
\hline
0.3 & 0 & 3 & B & Two vector registers (RD, RS) and a broadcast 8-bit immediate operand (IM1). \\
\hline
0.4 & 0 & 4 & A & One vector register (RD), a memory operand with pointer (RT) and vector length specified by a general purpose register (RS). \\
\hline
0.5 & 0 & 5 & A & One vector register (RD), a memory operand with base pointer (RT). Negative index and vector length are both specified by RS. This is used for vector loops as explained on page \pageref{vectorLoops}. \\
\hline
0.6 & 0 & 6 & A & One vector register (RD) and a scalar memory operand with base pointer (RT) and index (RS) scaled by operand size. \\
\hline
0.7 & 0 & 7 & B & One vector register (RD) and a scalar memory operand with base pointer (RS) and 8-bit offset. \\
\hline
0.8 & 0 & 0 M=1 & A & One general purpose register (RD) and a memory operand with base   pointer (RT) and index (RS) scaled by operand size.  \\
\hline
0.9 & 0 & 1 M=1 & B & One general purpose register (RD) and a memory operand with base pointer  (RT) and 8-bit offset. \\
\hline
1.0 & 1 & 0 & A & Single-format instructions. Three general purpose register operands. \\
\hline
1.1 & 1 & 1 & C & Single-format instructions. One general purpose register and a 16-bit immediate operand. \\
\hline
1.2 & 1 & 2 & A & Single-format instructions. Three vector register operands.  \\
\hline
1.3 & 1 & 3 & B, C & Single-format instructions. Two vector registers and a broadcast8-bit immediate operand, or one vector register and a broadcast 16-bit immediate operand. \\
\hline
1.4 & 1 & 4 & B & Jump instructions with two register operands and 8 bit offset.  \\
\hline
1.5 & 1 & 5 & C, D & Jump instructions with one register operand, 8 bit constant (IM2) and 8 bit offset (IM1), or no register and 24 bit offset.  \\
\hline
1.8 & 1 & 0 M=1 & B & Single-format instructions. Two general purpose registers and an 8-bit immediate operand. \\
\hline
T & 1 & 6-7 & T & Two tiny instructions. \\
\hline
2.0 & 2 & 0 & A2 & Two general purpose registers (RD, RS) and a memory operand with base (RT) and 32 bit offset (IM2). \\
\hline
2.1 & 2 & 1 & A2 & Three general purpose registers and a 32-bit immediate operand IM2. \\
\hline
2.2 & 2 & 2 & A2 & One vector register (RD) and a memory operand with base (RT) and 32 bit offset (IM2). Vector length specified by general purpose register RS. \\
\hline
2.3 & 2 & 3 & A2 & Three vector registers and a broadcast 32-bit immediate operand IM2. \\
\hline
2.4.0 & 2 & 4 & E2 & OP3=00xxxx. Two vector registers (RD, RU) and a scalar memory operand with base (RT) and 16 bit offset (IM2), broadcast to length (RS). \\
\hline
2.4.1 & 2 & 4 & E2 & OP3=01xxxx. Two vector registers (RD, RU) and a memory operand with base (RT), 16 bit offset (IM2), length (RS). \\
\hline
2.4.2 & 2 & 4 & E2 & OP3=10xxxx. Two vector registers (RD, RU) and a memory operand with base (RT), negative index (RS), and length (RS). Optional support for offset IM2 $\neq$ 0, otherwise IM2 = 0. \\
\hline
2.4.3 & 2 & 4 & E2 & OP3=11xxxx. Two vector registers (RD, RU) and a scalar memory operand with base (RT), scaled index (RS), and limit RS $\leq$ IM2 (unsigned). \\
\hline
2.5 & 2 & 5 & E2 & Three vector registers (RD, RS, RT) and a broadcast 16-bit immediate integer IM2. IM2 is shifted left by the 6-bit unsigned value of OP3, unless OP3 is used for other purposes. RU is usually unused. \\
\hline
2.6 & 2 & 6 & A2 & Single-format instructions. Three general purpose registers and a 32-bit immediate operand. \\
\hline
2.7 & 2 & 7 & A2, B2, C2 & Jump instructions (OP1 $<$ 16). Single-format instructions. Three vector registers and a 32-bit immediate operand. \\
\hline
2.8.0 & 2 & 0 M=1 & E2 & OP3=00xxxx. Three general purpose registers (RD, RS, RU) and a memory operand with base (RT) and 16 bit offset (IM2).  \\
\hline
2.8.1 & 2 & 0 M=1 & E2 & OP3=01xxxx. Two general purpose registers (RD, RU) and a memory operand with base (RT), index (RS), no scale. Optional support for offset IM2 $\neq$ 0, otherwise IM2 = 0. \\
\hline
2.8.2 & 2 & 0 M=1 & E2 & OP3=10xxxx. Two general purpose registers (RD, RU) and a memory operand with base (RT), scaled index (RS). Optional support for offset IM2 $\neq$ 0, otherwise IM2 = 0. \\
\hline
2.8.3 & 2 & 0 M=1 & E2 & OP3=11xxxx. Two general purpose registers (RD, RU) and a memory operand with base (RT), scaled index (RS), and limit RS $\leq$ IM2 (unsigned). \\
\hline
2.9 & 2 & 1 M=1 & E2 & Three general purpose registers (RD, RS, RT) and a 16-bit immediate integer IM2. IM2 is shifted left by the 6-bit unsigned value of OP3, unless OP3 is used for other purposes. RU is usually unused. \\
\hline
3.0 & 3 & 0 & A3, B3 & Jump instructions. Single-format instructions with general purpose register operands. Optional. \\
\hline
3.1 & 3 & 1 & A3 & Three general purpose registers and a 64-bit immediate operand. Optional.  \\
\hline
3.2 & 3 & 2 & A3 & Single-format vector instructions. Optional. \\
\hline
3.3 & 3 & 3 & A3 & Three vector registers and a broadcast 64-bit immediate operand. Optional. \\
\hline
3.8 & 3 & 0 M=1 & & Currently unused. \\
\hline
4.x & 3 & 4-7 &  & Reserved for future 4-word instructions and longer. \\
\hline
\end{longtable}


\section{Coding of operands}
\subsection{Operand type}
The type and size of operands is determined by the OT field as indicated above. The operand type is 64 bit integer (OS = 8) by default if there is no OT field. 

\subsection{Register type}
The instructions can use either general purpose registers or vector registers. General purpose registers are used for source and destination operands and for masks if mode is 0 or 1 (with M = 0 or 1). Vector registers are used for source and destination operands and for masks if mode is 2-7. A value of zero in the mask field indicates no mask and unconditional operation.

\subsection{Pointer register}
Instructions with a memory operand always use an address relative to a base pointer. The base pointer can be a general purpose register, the data section pointer, or the instruction pointer. The pointer is determined by the RS or RT field. This field is interpreted as follows.
\vspace{2mm}

Instruction formats with no offset or 8-bit offset (0.4-0.9) can use any of the registers r0-r31 as base pointer. r31 is the stack pointer.
\vspace{2mm}

Instruction formats with 16-bit or 32-bit offset (2.0, 2.2, 2.4, 2.8) can use the same registers, except r29 which is replaced by the data section pointer (DATAP), and r30 which is replaced by the instruction pointer (IP). This also applies to formats with an unused 16-bit offset (format 2.4.2 and 2.4.3).
\vspace{2mm}

Tiny instructions with a memory operand can use r0-r14 or the stack pointer (r31) as pointer in the 4-bit RS field. A value of 15 in the RS field indicates the stack pointer.

\subsection{Index register}
Instruction formats with an index can use r0-r30 as index. A value of 31 in the index field (RS) means no index. The signed index is multiplied by the operand size (OS) for formats 0.6, 0.8, 2.4.3, 2.8.2, 2.8.3; by 1 for format 2.8.1; or by -1 for format 0.5 and 2.4.2. The result is added to the value of the base pointer.

\subsection{Offsets}
Offsets can be 8, 16 or 32 bits. The value is sign-extended to 64 bits. An 8-bit offset is multiplied by the operand size OS, as given by the OT field. An offset of 16 or 32 bits is not scaled. The result is added to the value of the base pointer.
\vspace{2mm}

Support for addressing modes with both index and offset is optional (format 2.4.2, 2.8.1, 2.8.3). If this kind of addressing involving two additions is not supported then the offset in IM2 must be zero.

\subsection{Limit on index}
Formats 2.4.3 and 2.8.3 have a 16-bit limit on the index register. This is useful for checking array limits. If the value of the index register, interpreted as unsigned, is bigger than the unsigned limit then a trap is generated.

\subsection{Vector length}
The vector length of memory operands is specified by r0-r30 in the RS field for formats 0.4, 0.5, 2.2, 2.4. A value of 31 in the RS field indicates a scalar with the same length as the operand size (OS).
\vspace{2mm}

The value of the vector length register gives the vector length of the memory operand in bytes (not the number of elements). If the value is bigger than the maximum vector length then the maximum vector length is used. The value may be zero. The behavior for negative values is implementation dependent: either interpret the value as unsigned or use the absolute value.
\vspace{2mm}

The vector length must be a multiple of the operand size OS, as indicated by the OT field. If the vector length is not a multiple of the operand size then the behavior of the partial vector element is implementation dependent.
\vspace{2mm}

The vector length for source operands in vector registers is saved in the register.

\subsection{Combining vectors with different lengths}
The vector length of the destination will be the same as the vector length of the first source operand (even if the first source operand uses the RD field).
\vspace{2mm}

A consequence of this is that the length of the result is determined by the order of the operands when two vectors of different lengths are combined.
\vspace{2mm}

If the source operands have different lengths then the lengths will be adjusted as follows. If a vector source operand is too long then the extra elements will be ignored. If a vector source operand is too short then the missing elements will be zero.
\vspace{2mm}

A scalar memory operand (format 0.6 and 0.7) is not broadcast but treated as a short vector. It is padded with zeroes to the vector length of the destination.
\vspace{2mm}

A broadcast memory operand (format 2.4.1) will use the vector length given by the vector length register in the RS field.
\vspace{2mm}

A broadcast immediate operand will use the same vector length as the destination.

\subsection{Immediate constants}
Immediate constants can be 4, 8, 16, 32, and optionally 64 bits. Immediate fields are generally aligned to natural addresses. They are interpreted as follows.
\vspace{2mm}

If OT specifies an integer type then the field is interpreted as an integer. If the field is smaller than the operand size then it is sign-extended to the appropriate size. If the field is larger than the operand size then the superfluous upper bits are ignored. The truncation of a too large immediate operand will not trigger any overflow condition.
\vspace{2mm}

If OT specifies a floating point type then the field is interpreted as follows. Immediate fields smaller than 32 bits are interpreted as signed integers and converted to floating point numbers of the desired precision. A 32-bit field is interpreted as a single precision floating point number. It is converted to the desired precision if necessary. A 64-bit field (if supported) is interpreted as a double precision floating point number. A 64-bit field is not allowed with a single precision operand type. A few optional instructions in format 1.3C have a half-precision floating point immediate constant that is converted to a single or double precision scalar.
\vspace{2mm}

16-bit immediate constants in format 2.5 and 2.9 can be shifted left by the 6-bit unsigned value of OP3 to give a 64-bit signed value. Any overflow beyond 64 bits is ignored. The shift is done before any conversion to floating point. No shifting is done if OP3 is used for other purposes.
\vspace{2mm}

An instruction can be made compact by using the smallest immediate field size that fits the actual value of the constant.

\subsection{Mask register}
The 3-bit mask field indicates a mask register. Register r1-r7 is used if the destination is a general purpose register. Vector register v1-v7 is used if the destination is a vector register. A value of zero in the mask field means no mask and unconditional execution using the options specified in the numeric control register.
\vspace{2mm}

If the mask is a vector register then it is interpreted as a vector with the same element size as indicated by the OT field. Each element of the mask register is applied to the corresponding element of the result.
\vspace{2mm}

The meanings of the flag bits are described in the next section.

\section{Coding of masks}
A mask register can be a general purpose register r1-r7 or a vector register v1-v7. A value of zero in the mask field means no mask.
\vspace{2mm}

The bits in the mask register are coded as follows.

\begin{longtable}
{|p{15mm}|p{90mm}|}
\caption{Bits in mask register and numeric control register}
\label{table:maskBits}
\endfirsthead
\endhead
\hline
 Bit number & Meaning \\
 \hline
0 & Predicate or mask. The operation is executed only if this bit is one. If this bit is zero then the operation is not executed, and any arithmetic error condition is suppressed. \\
\hline
1 & Zeroing. This bit determines the result when bit 0 is zero. Bit 1 = 0 makes the result zero. Bit 1 = 1 makes the value unchanged, i. e. the output is the same as the input from the first source operand. Bit 1 has no effect when bit 0 = 1. \\
\hline
2 & Detect unsigned integer overflow. \\
\hline
3 & Detect signed integer overflow. \\
\hline
6 & Propagate error bits detected by bit 2 or 3. This feature is tentative, see page \pageref{integerOverflowDetection}. \\
\hline
7 & Generate a trap if overflow as indicated by bit 2 or 3 is detected. \\
\hline
18-19 & Floating point rounding mode: \newline
00 = nearest or even \newline
01 = down \newline
10 = up \newline
11 = towards zero \\
\hline
20 & Support subnormal numbers. Subnormal floating point numbers are treated as zero or flushed to zero when this bit is 0 (this is generally faster). \\
\hline
22 & Better NAN propagation. If this bit is zero then the IEEE Standard 754-2008 (or later) is followed strictly for NAN values. A value of one in bit 22 improves NAN propagation and the use of NANs for tracing floating point errors. The details are described on page \pageref{nanPropagation}. \\
\hline
26 & Enable trap on floating point overflow and division by zero.  \\
\hline
27 & Enable trap on floating point invalid operation. \\
\hline
28 & Enable trap on floating point underflow and precision loss. \\
\hline
29 & Enable trap for NAN inputs to compare instructions and floating point to integer conversion instructions.  \\
\hline
\end{longtable}

Bits 8-9, 16-17, 24-25, etc. in a vector mask register can be used like bits 0-1 for 8-bit and 16-bit operand sizes. All other bits are reserved for future use.
\vspace{2mm}

Vector instructions treat the mask register as a vector with the same element size (OS) as the operands. Each element of the mask vector has the bit codes as listed above. The different vector elements can have different mask bits.
\vspace{2mm}

The numeric control register (NUMCONTR) is used as mask when the mask field is zero or absent. The NUMCONTR register is broadcast to all elements of a vector, using as many bits of NUMCONTR as indicated by the operand size, when an instruction has no mask register. 
The same mask is applied to all vector elements in this case. 
Bit 0 in NUMCONTR must be 1.

\section{Format for jump, call and branch instructions}
Most branches in ordinary code are based on the result of an arithmetic or logic instruction (ALU). The ForwardCom design combines the ALU instruction and the conditional jump into a single instruction. For example, a loop control can be implemented with a single instruction that counts down and jumps until it reaches zero or counts up through negative values and jumps until it reaches zero.
\vspace{2mm}

The jumps, calls, branches and multiway branches will use the following formats.

\begin{longtable}
{|p{10mm}|p{8mm}|p{8mm}|p{8mm}|p{8mm}|p{70mm}|}
\caption{List of formats for control transfer instructions}
\label{table:jumpInstructionFormats}
\endfirsthead
\endhead
\hline
Format & IL & Mode & OP1 & Tem-plate & Description \\
\hline
1.4 & 1 & 4 & OPJ & B & Short version with two register operands (RD, RS) and 8 bit offset  (IM1).  \\
\hline
1.5 C & 1 & 5 & OPJ & C & Short version with one register operand (RD), an 8-bit immediate constant (IM2) and 8 bit offset (IM1), or a 16-bit offset (IM2+IM1 combined). \\
\hline
1.5 D & 1 & 5 & 0-7 & D & Jump or call with 24-bit offset. \\
\hline
2.7.0 & 2 & 7 & 0 & B2 & Double size version with two register operands and 32 bit offset  (IM2). IM1 = OPJ. \\
\hline
2.7.1 & 2 & 7 & 1 & B2 & Double size version with a register destination operand, a register source operand, a 16-bit offset (IM2 lower half) and a 16-bit immediate operand (IM2 upper half).  \\
\hline
2.7.2 & 2 & 7 & 2 & C2 & Double size version with one register operand (RD), one 8-bit immediate constant (IM2) and 32 bit offset (IM3). \\
\hline
2.7.3 & 2 & 7 & 3 & C2 & Double size version with one register operand (RD), an 8-bit offset (IM2) and a 32-bit immediate constant (IM3).  \\
\hline
2.7.4 & 2 & 7 & 4 & C2 & Double size system call, no OPJ, 16 bit constant (IM1,IM2) and 32-bit constant (IM3). \\
\hline
3.0.0 & 3 & 0 & 0 & C2 & No operation (NOP). \\
\hline
3.0.1 & 3 & 0 & 1 & B3 & Triple size version with a register destination operand, a register source operand, a 32-bit immediate operand (IM2) and a 32-bit offset (IM3). Optional.  \\
\hline
\end{longtable}

The jump, call and branch instructions have signed offsets of 8, 16, 24 or 32 bits relative to the instruction pointer. Or, more precisely, relative to the end of the instruction. This offset is multiplied by the instruction word size (= 4) to cover an address range of $\pm$ a half kilobyte for short conditional jumps with 8 bits offset, $\pm$ 128 kbytes for jumps and calls with 16 bits offset, $\pm$ 32 megabytes for 24 bits offset, and $\pm$ 8 gigabytes for 32 bits offsets. The optional triple-size format includes unconditional jump and call with a 64 bits absolute address.
\vspace{2mm}

The versions with template C and C2 have no OT field. The operand type is 64-bit integer when there is no OT field. It is not possible to use formats with template C or C2 with floating point types. The instructions will use vector registers (first element only) when there is an OT field and M = 1. In other words, the ALU-jump instructions will use vector registers only when a floating point type is specified (or 128-bit integer type, if supported). General purpose registers are used in all other cases. It is possible to use bitwise logical instructions with vector registers by specifying a floating point type. 
\vspace{2mm}

The OPJ field defines the operation and jump condition. This field has 6 bits in the single size version and 8 bits in the longer versions. The two extra bits in the longer versions are used as follows. Bit 6 is reserved for future extensions, and must be zero. Bit 7 may be used for indicating loop behavior as a hint for choosing the optimal branch prediction algorithm.
\vspace{2mm}

The lower 6 bits of the OPJ field contains the following codes.

\begin{longtable}
{|p{10mm}|p{11mm}|p{50mm}|p{35mm}|}
%\nopagebreak
\caption{List of control transfer instructions: jump, call, return}
\label{table:controlTransferInstructions}
\endfirsthead
\endhead
\hline
OPJ & bit 0 of OPJ & Function & Comment \\
\hline
0-7 & part of offset & Unconditional jump with 24-bit offset & Format 1.5 D \\
\hline
8-15 & part of offset & Unconditional call with 24-bit offset & Format 1.5 D \\
\hline
0-1 & invert & Subtract signed, jump if negative (sub\_sign\_jmpneg) & Format 1.4 and 
    2.7.0. No floating point. \\
\hline
2-3 & invert & Subtract signed, jump if positive (sub\_sign\_jmppos) & Format 1.4 and 2.7.0.
    No floating point. \\
\hline
4-5 & invert & Subtract unsigned, jump if borrow (sub\_unsign\_jmpborrow) & Format 1.4 and 2.7.0. No floating point. \\
\hline
6-7 & invert & Subtract unsigned, jump if not zero or borrow (sub\_unsign\_jmpnzc) & Format 1.4 and 2.7.0. No floating point. \\
\hline
8-9 & invert & Subtract, jump if not zero (sub\_jmpnzero) & Format 1.4 and 2.7.0. No floating point. \\
\hline
10-11 & invert & Subtract signed, jump if overflow (sub\_sign\_jmpovfl) & Format 1.4 and 2.7.0. No floating point. \\
\hline
12-15 & & Reserved for future use & Format 1.4 and 2.7.0. \\
\hline
16-17 & invert & Add signed, jump if negative (add\_sign\_jmpneg) & No floating point. \\
\hline
18-19 & invert & Add signed, jump if positive (add\_sign\_jmppos) & No floating point. \\
\hline
20-21 & invert & Add unsigned, jump if carry (add\_unsign\_jmpcarry) & No floating point. \\
\hline
20-21 & invert & Jump if either operand is $\pm$ infinite or NAN (cmp\_float\_jmpinfnan) & Floating point operands \\
\hline
22-23 & invert & Add unsigned, jump if not zero or carry (add\_unsign\_jmpnzc) & No floating point. \\
\hline
22-23 & invert & Jump if either operand is subnormal (cmp\_float\_jmpsubnorm) & Floating point operands \\
\hline
24-25 & invert & Add, jump if not zero (add\_jmpnzero) & No floating point \\
\hline
26-27 & invert & Add signed, jump if overflow (add\_sign\_jmpovfl) & No floating point  \\
\hline
28-29 & invert & Shift left by n, jump if not zero (shift\_jmpnzero) & Shift right unsigned if n negative \\
\hline
30-31 & invert & Shift left by n, jump if carry (shift\_jmpcarry) & Shift right unsigned if n negative  \\
\hline
32-33 & invert & Compare signed, jump if below (cmp\_sign\_jmpbelow) &  \\
\hline
34-35 & invert & Compare signed, jump if above (cmp\_sign\_jmpabove) &  \\
\hline
36-37 & invert & Compare unsigned, jump if below (cmp\_unsign\_jmpbelow) & Integer operands \\
\hline
36-37 & invert & Jump if either operand is NAN (cmp\_float\_jmpunordered) & Floating point operands \\
\hline
38-39 & invert & Compare unsigned, jump if above (cmp\_unsign\_jmpabove) & Integer operands  \\
\hline
38-39 & invert & Jump if either operand is $\pm$ infinite (cmp\_float\_jmpinf) & Floating point operands \\
\hline
40-41 & invert & Compare, jump if not equal (cmp\_jmpneq) & \\
\hline
42-43 & invert & Bitwise test, jump if not zero (test\_jmpnzero) &  \\
\hline
44-45 & invert & Bitwise and, jump if not zero (and\_jmpnzero) & \\
\hline
46-47 & invert & Bitwise or, jump if not zero (or\_jmpnzero) &  \\
\hline
48-49 & invert & Bitwise xor, jump if not zero (xor\_jmpnzero) & \\
\hline
50-51 & invert & Test single bit, jump if not zero (testbit\_jmpnzero) & \\
\hline
52-53 & invert & Test single bit on vector register, jump if not zero \newline (testbit\_jmpnzero) &  \\
\hline
54-57 & & Reserved for future use. & \\
\hline
58-59 & 0 jump \newline 1 call & Indirect with pointer address in register RS,
pointer offset in IM1 or IM2 (jump/call). & Format 1.4 and 2.7.0. \\
\hline
58-59 & 0 jump \newline 1 call & Unconditional direct jump/call with 16 bit or
32 bit offset or 64-bit absolute address (jump/call) & Format 1.5 C, 2.7.2, and
3.0.1. \\
\hline
60-61 & 0 jump \newline 1 call & Use table of addresses relative to RD. RT = table base, RS = index*OS (jump/call) & Format 1.4,\newline template A. \\
\hline
60-61 & 0 jump \newline 1 call & Unconditional jump or call to value of register RS (jump/call)  & Format 1.5. \\
\hline
62 & 0 & Return from function (return) & Format 1.4.  \\
\hline
62 & 0 & Return from system function (sys\_return) & Format 1.5.  \\
\hline
63 & 1 & System call. ID in register RT, shared memory block RD, length RS. No mask (sys\_call) & Format 1.4,\newline template A. \\
\hline
63 & 1 & System call. ID in constants, shared memory block RD, length RS (sys\_call) & Format 2.7.1, 2.7.4 and 3.0.1. \\
\hline
63 & 1 & Unconditional trap. Interrupt number in IM1 (trap). & Format 1.5. \\
\hline
63 & 1 & Filler for unused code memory. All fields are all 1's (filler). & Format 1.5. \\
\hline
63 & 1 & Trap if unsigned RD \textgreater{} IM3. IM2 = 38. Interrupt number is fixed  (cmp\_unsign\_trapabove). & Format 2.7.3. \\
\hline
\end{longtable}

Signed integer comparisons are corrected for overflow, but signed addition and subtraction are not. For example, if A is a large positive integer and B is a large negative integer then sub\_sign\_jmpneg will jump if the calculation of A-B overflows to give a negative result, but cmp\_sign\_jmpbelow will not jump because A is bigger than B.
\vspace{2mm}

The combined ALU and conditional jump instructions can be coded in the formats 1.4, 1.5 C, 2.7.0, 2.7.1, 2.7.2, 2.7.3, and 3.0.1, except subtraction which cannot be coded in format 1.5 C. Subtraction with an immediate constant can be replaced by addition with the negative constant. The code space that would have been used by subtraction in format 1.5 C is instead used for coding direct jump and call instructions with a 24-bit offset using format 1.5 D, where the lower three bits of OP1 are used as part of the 24-bit offset.
\vspace{2mm}

The add and subtract operations are usually not supported for floating point operands because the longer latencies of these floating point operations will complicate the pipeline design. Floating point compare is supported because it is possible to make a floating point compare operation in a single clock cycle, using unsigned integer compare on the combined exponent and significant with special handling of the sign bit and NAN values.
\vspace{2mm}

The test bit instruction (testbit\_jmpnzero) will test bit number n in the first operand, where n is the value of the second operand (RS or IM2). This is useful for testing bit fields, sign bits, and the output of compare instructions. The second operand is interpreted as an 8-bit unsigned integer regardless of the operand type.
\vspace{2mm}

The shift left instructions will shift the first operand left when the second operand is positive and shift right with zero extension when the second operand is negative. The carry is the last bit shifted out. The operands are interpreted as integers regardless of the operand type, but vector registers are used if a floating point operand type is specified (M = 1).
\vspace{2mm}

Unconditional and indirect jumps and calls use the formats indicated above, where unused fields must be zero. Bit 0 of the OPJ field is zero for jump instructions and one for call instructions.
\vspace{2mm}

\label{jumpTableInstruction}
The table-based indirect jump/call instructions are intended to facilitate multiway branches (switch/case statements), function tables in code interpreters, and virtual function tables in object oriented languages with polymorphism. The table of jump or call addresses is stored as signed offsets relative to an arbitrary reference point, which may be the table address, the code base, or any other reference point. The operand type specifies the size of the table entries. 16-bit and 32-bit table entries must be supported. Other sizes are optional. The use of relative addresses makes the table more compact than if 64-bit absolute addresses were used. This instruction works as follows. Calculate the address of a table entry as the base pointer (RT) plus the index (RS) multiplied by the operand size. Read a signed value from this address, and scale by 4. Sign-extend this value to 64 bits, and add the reference point (RD). Jump or call to the calculated address. The array index (RS) is scaled by the operand size, while the table entries are scaled by the instruction word size (4). Support for a mask is optional.
\vspace{2mm}

The table used by the table-based jump/call instructions may be placed in the constant data section (CONST). This makes it possible to use the table base as reference point and it improves security by giving read-only access to the table.
\vspace{2mm}

Return instructions do not need a stack offset when the calling conventions specified on page \pageref{functionCallingConventions} are used.
\vspace{2mm}

\label{systemCallInstruction}
System calls use ID numbers rather than addresses to identify system functions. 
The ID is the combination of a module ID identifying a particular system module or device driver and a function ID identifying a particular function within this module. The module ID and the function ID are both 16 or 32 bits, so that the combined system call ID is up to 64 bits.
The sys\_call instruction has the following variants:

\begin{longtable}
{|p{30mm}|p{30mm}|p{30mm}|p{30mm}|}
\caption{Variants of system call instruction}
\label{table:syscallInstructions}
\endfirsthead
\endhead
\hline
Format & Operand type & Function ID & Module ID \\
\hline
1.4 & 32 bit & RT bit 0-15 & RT bit 16-31  \\
\hline
1.4 & 64 bit & RT bit 0-31 & RT bit 32-63  \\
\hline
2.7.1 & 32 bit & IM2 bit 0-15 & IM2 bit 16-31 \\
\hline
2.7.4 & 64 bit & IM21 bit 0-15 & IM3 bit 0-31 \\
\hline
3.0.1 & 64 bit & IM2 bit 0-31 & IM3 bit 0-31 \\
\hline
\end{longtable}

The sys\_call instruction can indicate a block of memory to be shared with the system function. The address of the memory block is pointed to by the register specified in RD and the length is in register RS. This memory block, which the caller must have access rights to, is shared with the system function. The system function will get the same access rights to this block as the calling thread has, i. e. read access and/or write access. This is useful for fast transfer of data between the caller and the system function. No other memory is accessible to both the caller and the called function. If the RD and RS fields are both zero (i. e. indicating register r0) then no memory block is shared. The sys\_call instruction in format 2.7.4 cannot have a shared memory block.
\vspace{2mm}

Parameters for system functions are transferred in registers, following the same calling conventions as normal functions. The registers used for function parameters are usually different from the registers in the RD, RS and RT fields. Function parameters that do not fit into registers must reside in the shared memory block.
\vspace{2mm}

Traps work like interrupts. The unconditional trap has an 8-bit interrupt number in IM1. This is an index into the interrupt vector table, which initially starts at absolute address zero. The unconditional trap instruction may use IM2 for additional information. The conditional trap is intended for checking array bounds. The interrupt number is fixed (the value has not been decided yet). The conditional trap may optionally support other condition codes in IM2, using the same codes as OPJ in table \ref{table:controlTransferInstructions}.
\vspace{2mm}

A trap instruction with all 1's in all fields (opcode 0x6FFFFFFF) can be used as filler in unused parts of code memory.

\section{Assignment of opcodes}
The opcodes and formats for new instructions can be assigned according to the following rules.

\begin{itemize}
\item Multi-format instructions. Often-used instructions that need to support many different operand types, addressing modes and formats use most or all of the following formats: 0.0-0.9, 2.0-2.5, 2.8-2.9, and optionally 3.1 and 3.3 if triple-size instructions are supported. The same value of OP1 is used in all these formats. OP2 must be 0. Instructions with few source operands come first.

\item Tiny instructions. Only some of the most common instructions are available in tiny versions, as there is only space for 32 tiny instructions. The instructions are ordered according to the number and type of operands, as shown in table \ref{table:tinyInstructionsGP} page \pageref{table:tinyInstructionsGP}.

\item Control transfer instructions, i. e. jumps, branches, calls and returns, can be coded as short instructions with IL = 1, mode = 4-5, and OP1 = 0-63 or as double-size instructions with IL = 2, mode = 7, OP1 = 0-15, and optionally as triple-size instructions with IL = 3, mode = 0, OP1 = 0-15. See page \pageref{table:jumpInstructionFormats}.

\item Short single-format instructions with general purpose registers. Use mode 1.0, 1.1, and 1.8, with  any value of OP1.

\item Short single-format instructions with vector registers. Use mode 1.2 and 1.3
with any value of OP1.

\item Double-size single-format instructions with general purpose registers can use mode 2.8 and 2.9 with any value of OP1 and OP2 $\geq$ 8 (give similar instructions the same value of OP1), and mode 2.6 with any value of OP1.

\item Double-size single-format instructions with vector registers can use mode 2.4 and 2.5 with any value of OP1 and OP2 $\geq$ 8 (give similar instructions the same value of OP1), and mode 2.7 with OP1 in the range 16-63.

\item Triple-size single-format instructions with general purpose registers can use mode 3.0 with OP1 in the range 16-63.

\item Triple-size single-format instructions with vector registers can use mode 3.2 with any value in OP1.

\item Future instructions longer than three 32-bit words are coded with IL = 3, mode = 4-7.

\item New options or other modifications to existing instructions can use OP3 bits or mask register bits.

\item New addressing modes may be implemented as single-format read and write instructions. New addressing modes or other modifications that apply to all multi-format instructions can use OP3 for option bits. If the bits of OP3 are exhausted then it is possible, as a last resort, to use OP2 values in the range 1-7.


\end{itemize}

All unused fields must be zero. The instructions with the fewest input operands should preferably have the lowest OP1 codes. 
\vspace{2mm}

The operands are assigned as follows. The destination operand is a register specified in the RD field. Source operands use register fields RS, RT and RU, unless these fields are used for other purposes (i. e. base pointer, index, vector length). If there is a memory operand or an immediate operand then it will be the last source operand. If the chosen format has fewer source operands than needed for the instruction then RD is used as both destination and the first source operand. If there are still not enough operands then the format cannot be used for the specific instruction. If the format has more operands than needed then any memory operand or immediate operand will be the last source operand, taking precedence over any register operand. Unused operand fields must be zero.

\end{document}
