% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\RaggedRight

\chapter{Description of instructions}\label{chap:DescriptionOfInstructions}

\subsection{Data move and conversion instructions}

\subsubsection{broad}

\label{table:broadInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A &  6 & vector, g.p. register, and scalar \\ \hline
1.3 B & 18 & vector, g.p. register, and 8-bit signed constant \\ \hline
2.6   &  6 & vector, g.p. register, and 32-bit signed or float constant \\ \hline
3.1   &  9 & vector, g.p. register, and 64-bit signed or double constant \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = broad(r1, v2)\\
float v0 = broad(r1, 2.5)
\vspace{2mm}

Broadcast a constant or the first element of a source vector into all
elements of the destination vector with the length in bytes indicated by the first source operand (RS).
\vspace{2mm}

This instruction can have a mask but not a fallback register. The fallback value is zero.\\
(This instruction is not called broadcast because that is a reserved keyword).


\subsubsection{broadcast\_max}

\label{table:broadcastMaxInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 19 & vector and 8-bit signed constant \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = broadcast\_max(1)
\vspace{2mm}

Broadcast a small constant to all elements of a vector with maximum length.
\vspace{2mm}


\subsubsection{clear}
\label{table:clearInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
Tiny & 16 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

v0 = clear()
\vspace{2mm}

Clear vector register RD by setting the length to zero. All data are discarded. A cleared register is treated as unused. 

\subsubsection{compress}
\label{table:compressInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 6 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

double v0 = compress(v1, 0)
\vspace{2mm}

All the elements of a vector are converted to half the element size. The length of the output vector will be half the length of the input vector. The OT field specifies the operand type of the input vector. Double precision floating point numbers are converted to single precision. Integer elements are converted to half the size. Support for the following conversions are optional: single precision float to half precision, quadruple precision to double precision, 8-bit integer to 4-bit.
\vspace{2mm}

Overflow options and rounding mode are specified in IM1 as follows:

\label{table:compressOptions}
\begin{tabular}{|p{16mm}|p{130mm}|}
\hline
\bfseries IM1 bits & \bfseries meaning \\ \hline
bit 0-2 & Floating point exception control: \newline
000 = exceptions are controlled by NUMCONTR. See page \pageref{table:FPExceptionResults} \newline
001 = overflow generates NAN code \newline
010 = underflow generates NAN code \newline
011 = overflow and underflow generate NAN code \newline
100 = underflow and inexact generate NAN code \newline
101 = overflow, underflow, and inexact generate NAN code \newline
111 = no conditions generate NAN code
\\ \hline
bit 0-2 & Integer overflow control: \newline
000 = integer overflow wraps around \newline
100 = signed integer overflow gives zero \newline
101 = signed integer overflow gives signed saturation \newline
110 = unsigned integer overflow gives zero \newline
111 = unsigned integer overflow gives unsigned saturation
\\ \hline
bit 3-5 & Floating point rounding mode: \newline
000 = rounding mode determined by NUMCONTR \newline
001 = odd if not exact \newline
100 = nearest or even \newline
101 = down \newline
110 = up \newline
111 = towards zero
\\ \hline
\end{tabular}
\vspace{2mm}

The rounding mode "odd if not exact" works in the following way: 
Truncate the superfluous mantissa bits. If the result is not exact then set the least significant bit to 1. 
This rounding mode is needed to avoid double rounding errors when rounding in multiple steps. Use odd rounding mode except in the last step. 
For example, to convert from double precision to half precision, use the odd rounding mode in the first step from double to single precision, then use "nearest or even" in the last step from single to half precision.
\vspace{2mm}

Overflow in integer conversion can be detected by doing the conversion twice, using an "overflow gives zero" option and the corresponding saturation option. Overflow has occurred if the two results are different.
\vspace{2mm}

NANs are converted by preserving the least significant bits of the payload and the quiet bit. This differs from most other microprocessors, which preserve the most significant bits of binary floating point NAN payloads.
\vspace{2mm}


\subsubsection{compress\_sparse}
\label{table:compressSparseInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 8 & vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Compress sparse vector elements indicated by mask bits into contiguous vector. 

The length of the input vector is indicated by RS (bytes).
\vspace{2mm}

The algorithm of this instruction is:
Start with a zero-length destination vector.
For each element in the mask vector that is true, take an element from the corresponding position in the source vector and append it to the destination vector.
The length of the destination vector will be the number of true mask elements
times the element size.
\vspace{2mm}

This instruction cannot have a fallback register.
\vspace{2mm}


\subsubsection{concatenate}
\label{table:concatenateInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.2.6 & 0.1 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = concatenate(v1, r2, v3)
\vspace{2mm}

A vector RU of length RS bytes and a vector RT of
length RS bytes are concatenated into a vector RD
of length 2$\cdot$RS, with RT in the high end.
\vspace{2mm}

This instruction cannot have a mask.


\subsubsection{expand}
\label{table:expandInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 7 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

float  v0 = expand(v1, 0)
\vspace{2mm}

This is the opposite of compress. The length of the output vector is double the length of the input vector if the maximum vector length is not exceeded. 
\vspace{2mm}

The OT field specifies the operand type of the output vector. Single precision floating point numbers are converted to double precision. Integers are converted to the double size by sign-extension or zero-extension. Support for the following conversions are optional: half precision float to single precision, double precision to quadruple precision, 4-bit integer to 8-bit.
\vspace{2mm}

Options are specified in IM1:
\vspace{2mm}

\label{table:expandOptions}
\begin{tabular}{|p{20mm}|p{120mm}|}
\hline
\bfseries IM1 bits & \bfseries meaning \\ \hline
bit 0-1 & integer options: \newline
00 = sign extension \newline
10 = zero extension
\\ \hline
\end{tabular}
\vspace{2mm}


\subsubsection{expand\_sparse}
\label{table:expandSparseInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 9 & vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

This is the opposite of compress\_sparse.

Expand a contiguous vector into a sparse vector with positions indicated by mask bits. 

RS = length of the output vector.

\vspace{2mm}
The algorithm of this instruction is:\\
Set an index i1 to position zero in the source vector.\\
Let another index i2 loop through the mask vector. For each i2 do:\\
\hspace{4mm} if mask[i2] then\\
\hspace{8mm}   destination[i2] = source[i1]; increment i1\\
\hspace{4mm} else\\
\hspace{8mm}   destination[i2] = 0\\
  end for\\
  
\vspace{2mm}
The length of the destination vector will be the number of true mask elements
times the element size. This instruction cannot have a fallback register.
\vspace{2mm}


\subsubsection{extract}
\label{table:extractInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A &  5 & vectors  \\ \hline
1.3 B &  5 & vectors  \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = extract(r2, v1)\\
float v0 = extract(v1, 5)
\vspace{2mm}

Extract one element from the source vector at the given index and 
broadcast it into all elements of vector register RD with same length and operand size as the source vector. 
The index can be a constant or a general purpose register. 
The index is multiplied by the operand size.
\vspace{2mm}

An index out of range will produce zero. An operand size of 128 bits can be used, even if this size is not otherwise supported. 
This instruction cannot have a mask.
\vspace{2mm}


\subsubsection{float2int}
\label{table:extractInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 12 & vectors  \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = float2int(v1, 0)
\vspace{2mm}

Conversion of floating point values to integers with the same operand size.\\ 
float16 is converted to int16. float32 is converted to int32. float64 is converted to int64.
\vspace{2mm}

The bits in IM1 specify rounding mode and error control, according to the following table:
\vspace{2mm}

\label{table:float2intOptions}
\begin{tabular}{|p{16mm}|p{120mm}|}
\hline
\bfseries IM1 bit & \bfseries Meaning \\ \hline
0-2 & overflow control: \newline
000 = integer overflow wraps around \newline
100 = signed integer overflow gives zero \newline
101 = signed integer overflow gives signed saturation \newline
110 = unsigned integer overflow gives zero \newline
111 = unsigned integer overflow gives unsigned saturation \\
\hline
3-4 & rounding mode: \newline
00 = nearest or even\newline
01 = down\newline
10 = up\newline
11 = truncate towards zero \\ 
\hline
5 & 0: NAN gives 0. 1: NAN gives MIN\_INT \\
\hline
\end{tabular}
\vspace{2mm}

To check for overflow: Compare the results for overflow gives zero and overflow gives saturation. 

To check if the result is exact: Compare the results for round down and round up.


\subsubsection{get\_len}
\label{table:getLenInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 1 & vectors  \\ \hline
\end{tabular}
\vspace{2mm}

Get length in bytes of vector register RT into general purpose register RD.
\vspace{2mm}

This instruction cannot have a mask.

\subsubsection{get\_num}
\label{table:getNumInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 3 & vectors  \\ \hline
\end{tabular}
\vspace{2mm}

Get the number of elements in vector register RT into general purpose register RD. This is equal to the length divided by the operand size. The result is a 64-bit integer.
\vspace{2mm}

This instruction cannot have a mask.

\subsubsection{gp2vec}
\label{table:gp2vecInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 0 & g.p register in, vector register out \\ \hline
\end{tabular}
\vspace{2mm}

int64 v0 = gp2vec(r1)
\vspace{2mm}

Move integer value of general purpose register RS to
scalar in vector register RD.
\vspace{2mm}


\subsubsection{insert}
\label{table:insertInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 4 & vectors \\
1.3 B & 4 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = insert(v0, r1, v2) \\
float v0 = insert(v0, v2, 5)
\vspace{2mm}

Replace one element in vector RD with the first element of the source vector. 
The index to the position of replacement can be a constant or a general purpose register. The index is multiplied with the operand size.
\vspace{2mm}

An index out of range will leave the vector unchanged. An operand size of 128 bits can be used, even if this size is not otherwise supported.
\vspace{2mm}

This instruction cannot have a mask.


\subsubsection{insert\_hi}
\label{table:insertHiInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.9 & 1 & general purpose register, 32-bit immediate constant \\ \hline
2.6 & 1 & vector register, 32-bit immediate constant \\ \hline
\end{tabular}
\vspace{2mm}

int64 r0 = insert\_hi(r1, 2) \\
float v0 = insert\_hi(v1, 2.1)
\vspace{2mm}

Insert 32-bit constant into the high part of a
general purpose register, leaving the low part
unchanged. \\
dest = (src1 \& 0xFFFFFFFF) $|$ (IM2 $<<$ 32).
\vspace{2mm}

Make a vector of two elements. A constant is inserted into the second element, leaving the first element unchanged.\\
dest[0] = src1[0], dest[1] = IM2.
\vspace{2mm}


\subsubsection{int2float}
\label{table:int2floatInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 13 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

int64 v0 = int2float(v1, 0)
\vspace{2mm}

Conversion of signed or unsigned integers to floating point numbers with same operand size.\\
int16 is converted to float16. int32 is converted to float32. int64 is converted to float64.
\vspace{2mm}

Options are coded in IM1:

\label{table:int2floatOptions}
\begin{tabular}{|p{20mm}|p{120mm}|}
\hline
\bfseries IM1\newline bit number & \bfseries Meaning \\ \hline
0 & The integer is unsigned \\
2 & Inexact result gives NAN. See page \pageref{table:FPExceptionResults}.
\\ \hline
\end{tabular}
\vspace{2mm}



\subsubsection{interleave}
\label{table:interleaveInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.2.6 & 2.1 & vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = interleave(v1, r2, v3)
\vspace{2mm}

Interleave the inputs from two vectors so that the even-numbered elements come from the first input vector and the odd-numbered elements come from the second input vector. The length in bytes of the destination vector is indicated by a general purpose register. The length of each input vector is half the indicated value.
\vspace{2mm}

This instruction can have a mask but not a fallback register. The fallback value is zero.

\subsubsection{load\_hi}
\label{table:loadHiInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.5 & 0 & vector. 32 bit immediate constant \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = load\_hi(1.2)
\vspace{2mm}

Make vector of two elements. dest[0] = 0, dest[1] = IM2.
\vspace{2mm}

\subsubsection{move}
\label{table:moveInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 2 & all types \\ \hline
tiny  & 1 & g.p. register = 4-bit zero-extended constant \\ \hline
tiny  & 8 & two g.p. registers \\ \hline
tiny  & 14 & g.p. register = memory operand with pointer \\ \hline
tiny  & 17 & single prec. float scalar = 4 bit unsigned integer constant \\ \hline
tiny  & 18 & double prec. float scalar = 4 bit unsigned integer constant \\ \hline
tiny  & 19 & two vector registers \\ \hline
1.1 C &  0 & g.p. register = 16-bit sign extended constant \\ \hline
1.1 C & 16 & g.p. register = 8-bit sign extended constant with left shift \\ \hline
1.3 C & 32 & vector register 16-bit scalar = 16-bit constant. Optional  \\ \hline
1.3 C & 40 & vector register 32-bit scalar = 8-bit sign extended constant with left shift. Optional \\ \hline
1.3 C & 41 & vector register 64-bit scalar = 8-bit sign extended constant with left shift. Optional \\ \hline
1.3 C & 56 & vector register single precision scalar = half precision immediate constant. Optional \\ \hline
1.3 C & 57 & vector register double precision scalar = half precision immediate constant. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Copy A value from a register, memory operand or immediate constant to a register. If the destination is a vector register and the source is an immediate constant then the result will be a scalar. The value will not be broadcast because there is no other input operand that specifies the vector length. If a vector is desired then use the broadcast instruction instead.
\vspace{2mm}

The move instruction with an immediate operand is the preferred method for setting a register to zero.


\subsubsection{move\_u}
\label{table:moveUInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.1 C & 1 & g.p. register, 16 bit unsigned constant \\ \hline
\end{tabular}
\vspace{2mm}

Copy 16-bit zero-extended constant to general
purpose register.

This can be used as the first step of loading a 32-bit constant if double size instructions are not supported.

\subsubsection{permute}
\label{table:permuteInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.2.6 & 1.1 & vectors \\ \hline
2.6   & 8   & vectors and 32 bit immediate constant \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = permute(v1, r2, v3) \\
float v0 = permute(r1, v2, 3) \\
\vspace{2mm}

This instruction permutes the elements of a vector. The vector is divided into blocks of size RS bytes each. The block size must be a power of 2 and a multiple of the operand size. Elements can be moved arbitrarily between positions within each block, but not between blocks. Each element of the output vector is a copy of an element in the input vector, selected by the corresponding index in an index vector. The indexes are relative to the start of the block they belong to, so that an index of zero will select the first element in the block of the input vector and insert it in the corresponding position of the output vector. The same element in the input vector can be copied to multiple elements in the output vector. An index out of range will produce a zero. The indexes are interpreted as  integers regardless of the operand type.
\vspace{2mm}

The permute instruction has two versions. The first version specifies the indexes in a vector with the same length and element size as the input vector.
\vspace{2mm}

The second version specifies the indexes as a 32-bit immediate constant with 4 bits per element. This constant is split into a maximum of 8 elements with 4 bits in each, where the least significant four bits is index for the first element in the block.
If the blocks have more than 8 elements each then the sequence of 8 elements is repeated to fill a block. The same pattern of indexes will be applied to all blocks in the second version of the permute instruction.
\vspace{2mm}

The maximum block size for the permute instruction is implementation-dependent and given by a special register. The reason for this limitation of block size is that the complexity of the hardware grows quadratically with the block size. A full permutation is possible if the vector length does not exceed the maximum block size. A trap is generated if RS is bigger than the maximum block size.
\vspace{2mm}

The outputs of multiple permute instructions can be combined by using indexes out of range to produce zeroes for unused outputs and then combine the outputs of multiple permutes by bitwise OR. 
The fallback value is zero if a mask is used.
\vspace{2mm}

Permute instructions are essential for a vector processor because it is often necessary to rearrange data to facilitate the vector processing. These instructions are useful for reordering data, for transposing a matrix, etc. 
\vspace{2mm}

Permute instructions can also be used for parallel table lookup when the block size is big enough to contain the entire table.
\vspace{2mm}

Finally, permute instructions can be used for gathering and scattering data within an area not bigger than the vector length or the block size.

\subsubsection{read\_insert}
\label{table:readInsertInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.5 A & 24 & vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = read\_insert(v0, r1, [r2+0x8, scalar])
\vspace{2mm}

Replace one element in vector RD, starting
at offset RS$\cdot$OS, with scalar memory operand
[RT+IM2].

(OS = operand size).

\subsubsection{repeat\_block}
\label{table:repeatBlockInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.2.7 & 8.1 & vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = repeat\_block(r1, v2, 8) 
\vspace{2mm}

Repeat a block of data to make a longer vector. This is the same as broadcast, but with a larger block of data. RT is an input vector containing a data block to repeat. IM2 is the length in bytes of the block to repeat. This must be a multiple of 4. RS is the length in bytes of the destination vector RD. This instruction is useful for matrix multiplication.
\vspace{2mm}

This instruction cannot have a mask.

\subsubsection{repeat\_within\_blocks}
\label{table:repeatWithinBlockInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.2.7 & 9.1 & vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = repeat\_within\_blocks(r1, v2, 8) 
\vspace{2mm}

This divides a vector into blocks and broadcasts the first element of each block to the rest of the block. The block size is given by IM2. This must be a multiple of the operand size, and at least 4 bytes. There may be a maximum limit to the block size. RS is the length in bytes of the destination vector RD. This instruction is useful for matrix multiplication.
\vspace{2mm}

For example, if the input vector contains (0,1,2,3,4,5,6,7,8) and the block size is 3 times the operand size, then the result will be (0,0,0,3,3,3,6,6,6).
\vspace{2mm}

This instruction cannot have a mask.

\subsubsection{replace}
\label{table:replaceInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.6 & 3 & vectors and 32-bit immediate constant \\ \hline
3.1 & 8 & vectors and 64-bit immediate constant. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = replace(v1, 1), mask=v2, fallback=v3\\
double v0 = replace(v1, 2.3)
\vspace{2mm}

All elements of src1 are replaced by the integer or floating point constant src2.
\vspace{2mm}

When used without a mask, the constant is simply broadcast to make a vector of the same length as src1. This is useful for broadcasting a constant to all elements of a vector. Only the length of src1 (in bytes) is used, not its contents, when this instruction is used without a mask.
\vspace{2mm}

When used with a mask, the elements of src1 are selectively replaced. Elements that are not selected by the mask will be taken from a fallback register.


\subsubsection{replace\_even}
\label{table:replaceEvenInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.6 & 4 & vectors and 32-bit immediate constant \\ \hline
\end{tabular}
\vspace{2mm}

Same as replace. Only even-numbered vector elements are replaced.

\subsubsection{replace\_odd}
\label{table:replaceOddInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.6 & 5 & vectors and 32-bit immediate constant \\ \hline
\end{tabular}
\vspace{2mm}

Same as replace. Only odd-numbered vector elements are replaced.

\subsubsection{rotate\_down}
\label{table:rotateDownInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 & 21 & vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = rotate\_down(r1, v2)
\vspace{2mm}

Rotate vector down one element. Element number n is moved to position n-1, and element number zero is moved to the last position. The length of the vector in bytes is indicated by general purpose register RS.
\vspace{2mm}

This instruction cannot have a mask.

\subsubsection{rotate\_up}
\label{table:rotateUpInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 & 20 & vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = rotate\_up(r1, v2)
\vspace{2mm}

Rotate vector up one element. Element number n is moved to position n+1, and the last element is moved to position zero. The length of the vector in bytes is indicated by general purpose register RS.
\vspace{2mm}

This instruction cannot have a mask.


\subsubsection{set\_len}
\label{table:setLenInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 & 0 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

v1 = set\_len(r2, v3)
\vspace{2mm}

Sets the length of a vector register to the number of bytes specified by a general purpose register. If the specified length is more than the maximum length for the specified operand type then the maximum length will be used.
\vspace{2mm}

If the output vector is longer than the input vector then the extra elements will be zero. If the output vector is shorter than the input vector then the extra elements will be discarded. 
\vspace{2mm}

This instruction cannot have a mask.


\subsubsection{set\_num}
\label{table:setNumInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 & 2 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

The length of vector register RT is changed to the value of general purpose register RS. The length is indicated as number of elements. If the length is increased then the extra elements will be zero. If the length is decreased then the superfluous elements are lost.

\vspace{2mm}
This instruction differs from set\_len by multiplying RS with the operand size.

This instruction cannot have a mask.


\subsubsection{shift\_down}
\label{table:shiftDownInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 & 19 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = shift\_down(r1, v2)
\vspace{2mm}

Shift elements of vector RT down by the number of elements indicated by general purpose register RS. 
The upper RS elements of RD will be zero, the lower RS elements of RT are lost. The length of the vector is not changed.
\vspace{2mm}

This instruction differs from shift\_reduce by indicating the shift count as a number of elements rather than a number of bytes, and by not changing the length of the vector.
\vspace{2mm}

This instruction cannot have a mask.


\subsubsection{shift\_expand}
\label{table:shiftExpandInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 & 16 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = shift\_expand(r1, v2)
\vspace{2mm}

The length of a vector is expanded by the specified number of bytes by adding zero-bytes at the low end and shifting all bytes up. If the resulting length is more than the maximum vector length for the specified operand type then the upper bytes are lost.
\vspace{2mm}

This instruction cannot have a mask.

\subsubsection{shift\_reduce}
\label{table:shiftReduceInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 & 17 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = shift\_reduce(r1, v2)
\vspace{2mm}

The length of a vector is reduced by the specified number of bytes by removing bytes at the low end and shifting all bytes down. If the resulting length is less than zero then the result will be a zero-length vector. The specified operand type is ignored.

\vspace{2mm}
This instruction cannot have a mask.

\subsubsection{shift\_up}
\label{table:shiftUpInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 & 18 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = shift\_up(r1, v2)
\vspace{2mm}

Shift elements of vector RT up by the number of elements indicated by general purpose register RS. 
The lower RS elements of RD will be zero, the upper RS elements of RT are lost. The length of the vector is not changed.
\vspace{2mm}

This instruction differs from shift\_expand by indicating the shift count as a number of elements rather than a number of bytes, and by not changing the length of the vector.
\vspace{2mm}

This instruction cannot have a mask.


\subsubsection{sign\_extend}
\label{table:signExtendInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 4 & general purpose and integer scalar \\ \hline
\end{tabular}
\vspace{2mm}

int8 r0 = sign\_extend(r1)  // result is 64 bits\\
int8 v0 = sign\_extend(v1)  // lower 8 bits of each 64-bit element is extended to 64 bits\\
int8 v0 = sign\_extend([r1, scalar]) // memory operand is 8 bits, result is 64 bits scalar
\vspace{2mm}

Sign-extend smaller integer to 64 bits.

\vspace{2mm}
The input can be an 8-bit, 16-bit or 32-bit integer. This integer is sign-extended to produce a 64-bit output in a general purpose register or a scalar in a vector register. If the input is a vector then only the first element in each 64-bit block of the input vector is used. Floating point types cannot be used.

\subsubsection{sign\_extend\_add}
\label{table:signExtendAddInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 5 & general purpose registers. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int8 r0 = sign\_extend\_add(r1, r2) \\ 
int32 r0 = sign\_extend\_add(r1, [r2])
\vspace{2mm}

src2 is an integer of 8, 16, or 32 bits, usually a memory operand.
This integer is sign-extended to produce a 64-bit integer. The value is added to the 
64-bit integer in src1 and the result is stored in the 64-bit destination register.
\vspace{2mm}

This instruction is useful for loading relative pointers from memory, where the reference
point is in src1.
\vspace{2mm}

This instruction will not generate traps in case of signed or unsigned overflow, regardless of mask and  NUMCONTR.
\vspace{2mm}


\subsubsection{vec2gp}
\label{table:vec2gpInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 1 & vector register in, g.p. register out \\ \hline
\end{tabular}
\vspace{2mm}

int64 r0 = vec2gp(v1)
\vspace{2mm}

Copy value of first element of vector register RS to general purpose register RD. Integers are sign-extended. Single precision floating point values are zero-extended.

\vspace{2mm}
\subsection{Data read and write instructions}

\subsubsection{add\_cps}
\label{table:addCpsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
tiny & 28 & vector and g.p. register \\ \hline
\end{tabular}
\vspace{2mm}

Add compressed size.
\vspace{2mm}

This instruction gets the size of the compressed image for vector RD and adds it to general purpose register RS.
This is used for updating the stack pointer or any other pointer
after restoring a vector from a compressed memory image.
\vspace{2mm}

See save\_cp page \pageref{table:saveCpInstruction} for details.

\subsubsection{extract\_store}
\label{table:extractStoreInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.5 A & 32 & vector. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 [r3+8, scalar] = extract\_store(v1, r2)
\vspace{2mm}

Extract one element from vector RD, starting at offset RS$\cdot$OS, with size OS into memory operand [RT+IM2].

(OS = operand size).


\subsubsection{fence}
\label{table:fenceInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.5 B & 16 & memory operand and immediate. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32   fence([r1], 2)
\vspace{2mm}

Memory fence at address [RS+IM2].
\vspace{2mm}

Options indicated by IM1:

\begin{longtable}{|p{20mm}|p{50mm}|}
\endfirsthead
\endhead
\hline
\bfseries IM1 value & \bfseries meaning \\ \hline
1 & read fence \\ \hline
2 & write fence \\ \hline
3 & read and write fence \\ \hline
\end{longtable}
\vspace{2mm}

\subsubsection{move}
The move instruction, described at page \pageref{table:moveInstruction}
can read a register from a memory operand.

\subsubsection{prefetch}
\label{table:prefetchInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 3 & memory operand. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Prefetch memory operand into cache for later read or write.
Different variants (not yet defined) can be specified by IM3 for format with E template.

\subsubsection{restore\_cp}
\label{table:restoreCpInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
tiny & 30 & vector and memory operand \\ \hline
\end{tabular}
\vspace{2mm}

Restore compressed image.
\vspace{2mm}

This will restore vector register RD from a compressed memory image pointed to by general purpose register RS.
The memory image must have been written previously with the save\_cp instruction. See save\_cp for details.

\subsubsection{save\_cp}
\label{table:saveCpInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
tiny & 31 & memory operand and vector \\ \hline
\end{tabular}
\vspace{2mm}

Save compressed image.
\vspace{2mm}

This will save vector register RD to a compressed memory image pointed to by general purpose register RS.
\vspace{2mm}

This instruction is used for saving a vector register to the stack or to any other memory position in an efficient way that includes information about the vector length. When saving a vector register with variable length, we do not want to save the maximum length when only part of the register is used. Instead, we are using the save\_cp and restore\_cp instructions which are intended for saving and restoring a vector register without using more memory than necessary.

\vspace{2mm}

The format of the compressed memory image is implementation-dependent. Typically, it will contain an integer to indicate the vector length, followed by as many bytes of data as the length indicates. Any additional compression is allowed if it can be done sufficiently fast. It is recommended to include a 
checksum or hash of the data in order to check if the stack has been corrupted. The restore\_cp instruction may generate a trap when attempting to restore a vector where the checksum does not match the data. The compressed image of an empty vector will normally use only a single stack entry (8 bytes).
\vspace{2mm}

The size of the compressed image must be a multiple of the stack word size if the pointer register is the stack pointer.
\vspace{2mm}

The software should never use the saved image for anything else than restoring a vector register on the same microprocessor model that saved it, because the image format is not compatible across microprocessors.
\vspace{2mm}

The size of the saved image can be added to a pointer with the add\_cps instruction or subtracted from a pointer with the sub\_cps instruction. RS indicates the pointer, which can be r0-14 or r31 (stack pointer).
\vspace{2mm}

A vector register V can be saved (pushed) on the stack with the following pair of tiny instructions:

\begin{lstlisting}[frame=none]
   sp = sub_cps(sp,V)
   [sp] = save_cp(V)
\end{lstlisting}

A vector register V can be restored (popped) from the stack with the following pair of tiny instructions:

\begin{lstlisting}[frame=none]
   V = restore_cp([sp])
   sp = add_cps(sp,V)
\end{lstlisting}

The same instructions can be used for saving vector registers during a task switch. Unused vector registers will only use very little space when saved in this way.
\vspace{2mm}

The restore\_cp instruction is allowed to read more bytes than necessary, up to the maximum vector length plus 8 bytes, and discard any superfluous bytes afterwards when the actual length is known.


\subsubsection{store}
\label{table:storeInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi &  1 & memory operand and g.p. or vector register \\ \hline
tiny  & 15 & memory operand and g.p. register \\ \hline
2.5 B &  8 & memory operand and 32-bit constant. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 [r0+r1*4] = r1\\ 
float [r0, length = r1] = v2 \\
float [r0 + 0x10] = 2.5
\vspace{2mm}

Write the value of a register or constant to a memory operand.
\vspace{2mm}

The size of the memory operand is determined by the operand size OS when a scalar memory operand is specified, or by the vector length register in RS when a vector operand is specified.
\vspace{2mm}

An immediate constant cannot be bigger than 32 bits. A 64 bit integer constant can only be used if it fits into a 32-bit signed integer. A float64 constant can only be used if it can be represented as single precision without loss of precision.
\vspace{2mm}

The hardware must be able to handle memory operand sizes that are not powers of 2 without touching additional memory (read and rewrite beyond the memory operand is not allowed unless access from other threads is blocked during the operation and any access violation is suppressed). 
It is allowed for the hardware to write the operand in a piecemeal fashion.
\vspace{2mm}

Masked operation with a mask of zero will store a fallback value or zero. Masking cannot leave a memory element untouched.

\subsubsection{sub\_cps}
\label{table:subCpsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
tiny & 29 & vector and g.p. register \\ \hline
\end{tabular}
\vspace{2mm}

Subtract compressed size.
\vspace{2mm}

This instruction gets the size of the compressed image for vector RD and subtracts it from general purpose register RS.
This is used for adjusting the stack pointer or any other pointer
before saving a vector to a compressed memory image.
\vspace{2mm}

See save\_cp page \pageref{table:saveCpInstruction} for details.

\subsection{General arithmetic instructions}

\subsubsection{abs}
\label{table:absInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B &  0 & g.p. registers \\ \hline
1.3 B & 16 & vector registers \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = abs(r1, 1)
\vspace{2mm}


Absolute value of signed number.
\vspace{2mm}

Signed integers can overflow when the input is the minimum value.
The handling of overflow for signed integers is controlled by the constant IM1 as follows:

\begin{longtable}{|p{12mm}|p{80mm}|}
\endfirsthead
\endhead
\hline
\bfseries IM1 & \bfseries result when input is INT\_MIN \\ \hline
0  & INT\_MIN (wrap around) \\ \hline
1  & INT\_MAX (saturation)  \\ \hline
2  & zero                   \\ \hline
\end{longtable}
\vspace{2mm}


\subsubsection{add}
\label{table:addInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi &  8 & all standard types \\ \hline
multi & 44 & float16. Optional \\ \hline
tiny  &  2 & g.p. register and 4-bit zero-extended constant \\ \hline
tiny  &  9 & two g.p. registers \\ \hline
tiny  & 20 & two vector registers, single precision float \\ \hline
tiny  & 21 & two vector registers, double precision float \\ \hline
1.1 C &  2 & g.p. register and 16-bit sign-extended constant \\ \hline
1.1 C &  7 & g.p. register and 16-bit sign-extended constant shifted left by 16 \\ \hline
1.1 C & 17 & g.p. register and 8-bit sign-extended constant shifted left by another constant \\ \hline
2.9   &  2 & g.p. register and 32-bit zero-extended constant \\ \hline
2.9   &  4 & g.p. register and 32-bit constant shifted left by 32 \\ \hline
1.3 C & 33 & vector of 16-bit integer elements and broadcast 16 bit integer constant. Optional \\ \hline
1.3 C & 42 & vector of 32-bit integer elements and broadcast 8-bit sign-extended constant shifted left by another constant. Optional \\ \hline
1.3 C & 43 & vector of 64-bit integer elements and broadcast 8-bit sign-extended constant shifted left by another constant. Optional \\ \hline
1.3 C & 58 & single precision floating point vector and broadcast half precision floating point constant. Optional \\ \hline
1.3 C & 59 & double precision floating point vector and broadcast half precision floating point constant. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = r1 + r2 \\
int32 r0 = r1 + 2 \\
int32+ r0 += 4 \\
int32+ r0++ \\
float v0 = v1 + [r2 + 8, length = r5]
\vspace{2mm}

Addition.
\vspace{2mm}

If you want to add a 64-bit constant to a general purpose register, and triple size instructions are not supported, then add the lower half first using the zero-extended version, and then add the upper half using the shifted version.


\subsubsection{add\_add}
\label{table:addAddInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 50 & all types. Optional \\ \hline
\end{tabular}
\vspace{3mm}

This is two additions in one instruction:
\vspace{2mm}

dest = $\pm$ src1 $\pm$ src2 $\pm$ src3
\vspace{2mm}

For optimal precision with floating point operands, the intermediate sum of the two numerically largest operands should preferably be calculated first with extended precision.
\vspace{2mm}

Only instruction formats that allow three operands are supported.
\vspace{2mm}

The signs of the operands can be inverted as indicated by the following 3-bit code

\begin{longtable} {|p{20mm}|p{20mm}|p{75mm}|}
\caption{Control bits for add\_add} 
\label{table:ControlBitsForAddAdd} \\
\endfirsthead
\endhead
\hline
\bfseries Format with E template & \bfseries Other formats with mask & \bfseries Meaning   \\
\hline
IM3 bit 0 & mask bit 18 & change sign of src1 \\
IM3 bit 1 & mask bit 19 & change sign of src2 \\
IM3 bit 2 & mask bit 20 & change sign of src3 \\
\hline
\end{longtable}

There is no sign change if there is no IM3 field and no mask. 
\vspace{2mm}

This instruction should only be supported if it can be implemented so that it is faster than two consecutive add instructions. It may be supported for integer operands or floating point or both.

\subsubsection{compare} \label{compare}
\label{table:compareInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi &  7 & all types \\ \hline
\end{tabular}
\vspace{2mm}

int8 r0 = r1 $>$ r2 \\
uint8 r0 = r1 $>$ r2 \\
float v0 = v1 $>=$ 2.3 \\
int32 r0 = compare(r1, 2), mask=r3, fallback=r4, options=0x11
\vspace{2mm}

The compare instruction compares two source operands and generates a boolean scalar or vector where bit 0 indicates the result, and the remaining bits are copied from the mask or numeric control register. This instruction can do different compare operations depending on the following 4-bit condition code:

\begin{longtable} {|p{14mm}|p{55mm}|p{55mm}|}
\caption{Condition codes for compare instruction} 
\label{table:conditionCodesForCompareInstruction} \\
\endfirsthead
\endhead
\hline
\bfseries Bit 3-2-1-0 & \bfseries Meaning for integer & \bfseries Meaning for float \\
\hline
\_ 0 0 0 & a $=$ b & a $=$ b \\
\_ 0 0 1 & a $\neq$ b & a $\neq$ b \\
\_ 0 1 0 & a $<$ b & a $<$ b \\
\_ 0 1 1 & a $\geq$ b & a $\geq$ b \\
\_ 1 0 0 & a $>$ b & a $>$ b \\
\_ 1 0 1 & a $\leq$ b & a $\leq$ b \\
\_ 1 1 0 & abs(a) $<$ abs(b) & abs(a) $<$ abs(b) \\
\_ 1 1 1 & abs(a) $\geq$ abs(b) & abs(a) $\geq$ abs(b) \\
\hline
0 \_ \_ \_ & compare as signed & unordered gives 0 \\
1 \_ \_ \_ & compare as unsigned & unordered gives 1 \\
\hline
\end{longtable}
Details: The absolute values of integers are corrected for overflow so that abs(INT\_MIN) $>$ abs(INT\_MAX).
If a and b are both infinity then $a = b$ will be true, but $a-b = 0$ will be unordered.
You can check if a value is NAN by comparing it for unequal to itself with condition code 1001.

\vspace{2mm}
The condition codes are provided from different sources, depending on the instruction format:

\begin{longtable} {|p{25mm}|p{50mm}|p{50mm}|}
\caption{Source of condition codes} 
\label{table:SourceOfConditionCodes} \\
\endfirsthead
\endhead
\hline
\bfseries Formats & \bfseries Condition code from & \bfseries Remaining bits from \\
\hline
A template & mask bit 18-21 & mask \\
\hline
B template & zero & numeric control register \\
\hline
E template & IM3 bit 0-3 & mask \\
\hline
\end{longtable}

The condition code is zero (indicating compare for equal) if there is no mask and no IM3 field. The remaining bits are taken from the numeric control register if there is no mask.

\vspace{2mm}
Masking and fallback is possible. Alternative use of the fallback register (RU) as an extra boolean operand is supported with E template formats. The mask is regarded as true if there is no mask register.
This option is controlled by bits 4-5 of IM3:

\begin{longtable} {|p{25mm}|p{80mm}|}
\caption{Alternative use of fallback register} 
\label{table:AlternativeFallbackForCompare} \\
\endfirsthead
\endhead
\hline
\bfseries bit 5 bit 4 & \bfseries Output \\
\hline
\hspace{5mm} 0 0 & mask ? result : fallback \\
\hline
\hspace{5mm} 0 1 & mask \& result \& fallback \\
\hline
\hspace{5mm} 1 0 & mask \& (result $|$ fallback) \\
\hline
\hspace{5mm} 1 1 & mask \& (result \^{} fallback) \\
\hline
\end{longtable}
\vspace{2mm}

\subsubsection{div}
\label{table:divInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 16 & all types. Optional for integer vectors \\ \hline
1.1 C &  6 & g.p. register and 16-bit sign-extended constant \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = r1 / r2 \\
int32 r0 = div(r1, r2), options = 4\\
float v0 = v1 / [r2 + 8, length = r5]
\vspace{2mm}

Signed division.

\vspace{2mm}
This instruction has multiple rounding modes. The rounding mode for integer operands is controlled by IM3 in E template formats as follows:

\begin{longtable} {|p{25mm}|p{80mm}|}
\caption{division instructions} 
\label{table:DivInstructions} \\
\endfirsthead
\endhead
\hline
\bfseries IM3 bits 0-3 & \bfseries Meaning   \\
\hline
 0 0 0 0 & Truncate towards zero (default) \\
\hline
 0 1 0 0 & Nearest or even \\
 0 1 0 1 & Down \\
 0 1 1 0 & Up \\
 0 1 1 1 & Truncate towards zero \\
\hline
other values & Not allowed \\ 
\hline
\end{longtable}
Truncation is always used with integer operands in formats with no IM3 field.

\vspace{2mm}
The rounding mode for floating point operands is controlled by the mask or numeric control register. IM3 must be zero for floating point operands.

\vspace{2mm}
Division of floating point operands by zero gives $\pm$INF (or NAN if exceptions are enabled).

Division of integer operands by zero gives INT\_MAX or INT\_MIN.

Overflow occurs by division of INT\_MIN by -1. The result will wrap around to give INT\_MIN.

\subsubsection{div\_ex}
\label{table:divExInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 24 & Integer vectors. Optional for more than one element \\ \hline
\end{tabular}
\vspace{2mm}

Divide vector of double-size signed integers RS by signed integers RT. RS has element size 2$\cdot$OS. These are divided by the even numbered
elements of RT with size OS. The truncated results are stored in the even-numbered elements of RD. The remainders are stored in the odd-numbered elements of RD.
(OS = operand size).

\subsubsection{div\_ex\_u}
\label{table:divExUInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 25 & Integer vectors. Optional for more than one element \\ \hline
\end{tabular}
\vspace{2mm}

Divide vector of double-size unsigned integers RS by unsigned integers RT. RS has element size 2$\cdot$OS. These are divided by the even numbered elements of RT with size OS. The truncated results are stored in the even-numbered elements of RD. The remainders are stored in the odd-numbered elements of RD.
(OS = operand size).

\subsubsection{div\_rev}
\label{table:divRevInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 18 & all types. Optional for integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = 10 / r2 \\
int32 v0 = div\_rev(v1, v2), options = 4
\vspace{2mm}

Same as div, with the two source operands swapped.

The rounding mode is controlled in the same way as for the div instruction.

\subsubsection{div\_u}
\label{table:divUInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 17 & all integer types. Optional for integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

uint32 r0 = r1 / r2 \\
uint32 v0 = div\_u(v1, v2), options=4
\vspace{2mm}

Unsigned integer division.

The rounding mode is controlled in the same way as for the div instruction, see page \pageref{table:DivInstructions}

\vspace{2mm}
Division by zero gives UINT\_MAX.

\subsubsection{max}
\label{table:maxInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 24 & all types \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = max(r1, r2) \\
float v0 = max(v1, v2)
\vspace{2mm}

Get the maximum of two numbers:

max(src1,src2) = src1 \textgreater{} src2 ? src1 : src2
\vspace{2mm}

Integer operands are treated as signed.
\vspace{2mm}

The handling of floating point NAN operands follows the definition of the maximum function in the 2019 revision of the IEEE floating point standard 754, which guarantees the propagation of NANs, unlike the 1985 and 2008 versions of the standard.
\vspace{2mm}


\subsubsection{max\_abs}
\label{table:maxAbsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 25 & all floating point types \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = max\_abs(v1, v2)
\vspace{2mm}

Gives the maximum of the absolute values of two floating point numbers.
\vspace{2mm}

max\_abs(src1, src2) = max(abs(src1), abs(src2))
\vspace{2mm}

NAN values are treated in the same way as for the max instruction.

\subsubsection{max\_u}
\label{table:maxUInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 25 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

uint32 r0 = max\_u(r1, r2)
\vspace{2mm}

Gives the maximum of two unsigned integers.
\vspace{2mm}

max\_u(src1,src2) = src1 \textgreater{} src2 ? src1 : src2

\subsubsection{min}
\label{table:minInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 22 & all types \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = min(r1, r2)\\
float v0 = min(v1, v2)
\vspace{2mm}

Get the minimum of two numbers:

min(src1,src2) = src1 \textless{} src2 ? src1 : src2
\vspace{2mm}

Integer operands are treated as signed.
\vspace{2mm}

The handling of floating point NAN operands follows the definition of the minimum function in the 2019 revision of the IEEE floating point standard 754, which guarantees the propagation of NANs, unlike the 1985 and 2008 versions of the standard.
\vspace{2mm}

\subsubsection{min\_abs}
\label{table:minAbsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 23 & all floating point types \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = min\_abs(v1, v2)
\vspace{2mm}

Gives the minimum of the absolute values of two floating point numbers.
\vspace{2mm}

min\_abs(src1, src2) = min(abs(src1), abs(src2))
\vspace{2mm}

NAN values are treated in the same way as for the min instruction.

\subsubsection{min\_u}
\label{table:minUInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 23 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

uint32 r0 = min\_u(r1, r2)
\vspace{2mm}

Gives the minimum of two unsigned integers.
\vspace{2mm}

min\_u(src1,src2) = src1 \textless{} src2 ? src1 : src2

\subsubsection{mul}
\label{table:mulInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 11 & all standard types \\ \hline
multi & 46 & float16. Optional \\ \hline
tiny  & 24 & two single precision float vectors \\ \hline
tiny  & 25 & two double precision float vectors \\ \hline
1.1 C &  5 & general purpose register and 16-bit sign-extended constant \\ \hline
1.3 C & 60 & single precision floating point vector and broadcast half-precision floating point constant. Optional \\ \hline
1.3 C & 61 & double precision floating point vector and broadcast half-precision floating point constant. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = r1 * r2 \\
float v0 *= 5.0
\vspace{2mm}

Multiplication.
\vspace{2mm}

The same instruction can be used for signed and unsigned integers.

\subsubsection{mul\_add, mul\_add2}
\label{table:mulAddInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 48 & mul\_add: dest = $\pm$ src1 $\pm$ (src2 $\cdot$ src3). All types. Optional \\ 
multi & 49 & mul\_add2: dest = $\pm$ (src1 $\cdot$ src2) $\pm$ src3 . All types. Optional \\
multi & 47 & mul\_add. float16. Optional \\ \hline
\hline
\end{tabular}
\vspace{2mm}

Fused multiply and add.
\vspace{2mm}

The fused multiply-and-add instruction can often improve the performance of floating point code significantly. The intermediate product is calculated with extended precision according to the IEEE 754-2008 standard.
\vspace{2mm}

Only instruction formats that allow three operands are supported.
\vspace{2mm}

The signs of the operands can be inverted as indicated by the following 4-bit code

\begin{longtable} {|p{20mm}|p{20mm}|p{75mm}|}
\caption{Control bits for mul\_add} 
\label{table:ControlBitsForMulAdd} \\
\endfirsthead
\endhead
\hline
\bfseries E template formats & \bfseries A template formats & \bfseries Meaning   \\
\hline
IM3 bit 0 & mask bit 18 & change sign of addend in even-numbered vector elements \\
IM3 bit 1 & mask bit 19 & change sign of addend in odd-numbered vector elements \\
IM3 bit 2 & mask bit 20 & change sign of product in even-numbered vector elements \\
IM3 bit 3 & mask bit 21 & change sign of product in odd-numbered vector elements \\
\hline
\end{longtable}

\vspace{2mm}
These option bits make it possible to do multiply-and-add, multiply-and-subtract, multiply-and-reverse-subtract, etc. It can also do multiply with alternating add and subtract, which is useful in calculations with complex numbers. 
There is no sign change if there is no IM3 field and no mask. 

\vspace{2mm}
Support for integer operands is optional. Support for floating point operands is optional but desired.

\subsubsection{mul\_ex}
\label{table:mulExInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 14 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = mul\_ex(v1, v2 )
\vspace{2mm}

Extended multiply, signed.
\vspace{2mm}

Multiply even-numbered signed integer vector elements to double size result. The result extends into the next odd-numbered vector element.

\subsubsection{mul\_ex\_u}
\label{table:mulExUInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 15 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

uint32 v0 = mul\_ex\_u(v1, v2 )
\vspace{2mm}

Extended multiply, unsigned.
\vspace{2mm}

Multiply even-numbered unsigned integer vector elements to double size result. The result extends into the next odd-numbered vector element.

\subsubsection{mul\_hi}
\label{table:mulHiInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 12 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = mul\_hi(r1, r2) \\
int32 v0 = mul\_hi(v1, 2)
\vspace{2mm}

High part of signed integer product.
\vspace{2mm}

dest = (src1 $\cdot$ src2) $>>$ OS

(Signed, OS = operand size in bits).

\subsubsection{mul\_hi\_u}
\label{table:mulHiUInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 13 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

uint32 r0 = mul\_hi\_u(r1, r2)
\vspace{2mm}

High part of unsigned integer product.
\vspace{2mm}

dest = (src1 $\cdot$ src2) $>>$ OS

(Unsigned, OS = operand size in bits).


\subsubsection{rem}
\label{table:remInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 20 & all types. Optional for vectors of more than one element \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = r1 \% r2 \\
float v0 = rem(v1, v2)
\vspace{2mm}

Modulo. 

\vspace{2mm}
Signed with integer operands or floating point operands.

\vspace{2mm}
A floating point number modulo zero gives NAN.
An integer modulo zero gives zero.

\subsubsection{rem\_u}
\label{table:remUInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 21 & integers. Optional for vectors of more than one element \\ \hline
\end{tabular}
\vspace{2mm}

uint32 r0 = r1 \% r2
\vspace{2mm}

Unsigned modulo or remainder.

\vspace{2mm}
An integer modulo zero gives zero.


\subsubsection{round}
\label{table:roundInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 14 & floating point vectors \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = round(v1, 0)
\vspace{2mm}

Round floating point number to integer in floating point representation.
\vspace{2mm}

The rounding mode is specified in bit 0-1 of IM1. See table \ref{table:maskBits} page \pageref{table:maskBits}.


\subsubsection{roundp2}
\label{table:roundP2Instruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B &  3 & g.p. registers \\ \hline
\end{tabular}
\vspace{2mm}

int64 r0 = roundp2(r1, 1)
\vspace{2mm}

Round unsigned integer up or down to the nearest power of 2. Options:
\vspace{2mm}

\label{table:roundp2Options}
\begin{tabular}{|p{16mm}|p{122mm}|}
\hline
\bfseries IM1 bits & \bfseries meaning \\ \hline
bit 0 & 0: Round down to power or 2:\newline
dest = 1 \textless\textless{} bitscan\_reverse(src1).\newline
        1: Round up to power or 2:\newline
dest = ((src1 \& (src1-1)) == 0) ? src1 : 1 \textless\textless{}  (bitscan\_reverse(src1) + 1)
\\ \hline
bit 1 & 0: returns 0 if the input is 0.\newline
        1: returns -1 if the input is 0.\\ \hline
bit 2 & 0: returns 0 if the result overflows.\newline
        1: returns -1 if the result overflows.\\ \hline        
\end{tabular}
\vspace{2mm}


\subsubsection{round2n}
\label{table:round2nInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 15 & vector registers. Optional \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = round2n(v1, -4)
\vspace{2mm}

Round to nearest multiple of $2^n$.

dest = $2^n\cdot$ round($2^{-n}\cdot$ src1)

n is a signed integer constant in IM1.
\vspace{2mm}

\subsubsection{mul\_2pow}
\label{table:mul2PosInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 32 & all floating point types \\ \hline
\end{tabular}
\vspace{2mm}

Multiply by power of 2.

dest = src1 * $2^{src2}$

src1 and dest are floating point vectors, while src2 is interpreted as a signed integer vector with the same element size as src1 and dest.
\vspace{2mm}

This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.
\vspace{2mm}

Overflow will produce infinity. The result will be zero rather than a subnormal number in case of underflow, regardless of control bits in the mask or numeric control register. 
The reason for this is that
speed has priority here. This instruction will typically take a single clock cycle, while floating point multiplication by a power of 2 takes multiple clock cycles. 
This is useful for fast multiplication or division by a power of 2.


\subsubsection{shift\_left}
\label{table:shiftLeftInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 32 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

Shift integer left.

dest = src1 $<<$ src2
\vspace{2mm}

The result is zero if src2 is out of range.
\vspace{2mm}

This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.
\vspace{2mm}

\subsubsection{shift\_right\_s}
\label{table:shiftRightSInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 34 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

Shift integer right with sign extension (arithmetic shift).

dest = src1 $>>$ src2
\vspace{2mm}

The result is 0 or -1 if src2 is out of range.
\vspace{2mm}

This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.
\vspace{2mm}

\subsubsection{shift\_right\_u}
\label{table:shiftRightUInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 35 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

Shift integer right with zero extension (logical shift).

dest = src1 $>>$ src2
\vspace{2mm}

The result is zero if src2 is out of range.
\vspace{2mm}

This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.
\vspace{2mm}

\subsubsection{shift\_add}
\label{table:shiftAddInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B &  1 & g.p. registers \\ \hline
\end{tabular}
\vspace{2mm}

Shift left and and add. 
\vspace{2mm}

dest = src1 + (src2 \textless\textless{}  src3).
\vspace{2mm}

src1 must use the same register as dest. src3 is an 8-bit unsigned immediate constant in IM1.
\vspace{2mm}

\subsubsection{sqrt}
\label{table:sqrtInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 26 & floating point vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Square root.
\vspace{2mm}

The square root of a negative number gives NAN.

\subsubsection{sub}
\label{table:subInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi &  9 & all standard types \\ \hline
multi & 45 & float16. Optional \\ \hline
tiny  &  3 & g.p. register and 4-bit zero-extended constant \\ \hline
tiny  & 10 & two g.p. registers \\ \hline
tiny  & 22 & two vector registers, single precision float \\ \hline
tiny  & 23 & two vector registers, double precision float \\ \hline
2.9   &  3 & g.p. register and 32-bit zero-extended constant \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = r1 - r2 \\
int32 r0 = r1 - 2 \\
int32+ r0 -= 4 \\
int32+ r0-{-} \\
float v0 = v1 - [r2 + 8, length = r5]
\vspace{2mm}

Subtraction.

\subsubsection{sub\_rev}
\label{table:subRevInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 10 & all types \\ \hline
%1.1 C &  3 & g.p. register and 16-bit sign-extended constant \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = 1 - r2 \\
int32 v0 = - v2 + v1 \\
float v0 = -v1 + [r2 + 8, length = r5]
\vspace{2mm}

Reverse subtraction.
\vspace{2mm}

dest = src2 - src1.
\vspace{2mm}


\subsection{Arithmetic instructions with carry, overflow check, or saturation}
These instructions do not generate traps on overflow because they provide alternative ways of handling overflow.
\vspace{2mm}

\subsubsection{abs}
see page \pageref{table:absInstruction}.
\vspace{2mm}

\subsubsection{add\_c}
\label{table:addCInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 28 & integer vectors with two elements. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Addition with carry.
\vspace{2mm}

The vector has two elements. The upper element of src1 is used as carry in. The upper element of dest is used as carry out. Only the lower element of src2 is used.
\vspace{2mm}

Longer vectors are not supported. See page 
\pageref{highPrecisionArithmetic} for an alternative for longer vectors.

\subsubsection{add\_oc}
\label{table:addOcInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 38 & vector registers. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Integer addition with overflow check.
\vspace{2mm}

Instructions with overflow check use the even-numbered vector elements for arithmetic instructions. Each following odd-numbered vector element is used for overflow detection.
\vspace{2mm}

Overflow conditions are indicated with the following bits:
\vspace{2mm}

bit 0. Unsigned integer overflow (carry or borrow).

bit 1. Signed integer overflow.

\vspace{2mm}

The values are propagated so that the overflow result of the operation is OR'ed with the corresponding values of both input operands.
\vspace{2mm}

\subsubsection{add\_ss}
\label{table:addSsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 30 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Add signed integers with saturation.

Overflow and underflow produces INT\_MAX and INT\_MIN.

\subsubsection{add\_us}
\label{table:addUsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 31 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Add unsigned integers with saturation.

Overflow produces UINT\_MAX.

\subsubsection{compress\_ss}
\label{table:compressSsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 5 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Compress, signed with saturation.
\vspace{2mm}

Same as compress (see page \pageref{table:compressInstruction}). Integers are treated as signed and compressed with saturation. Floating point operands cannot be used. 
Masks cannot be used and overflow traps cannot be enabled for this instruction.
\vspace{2mm}

\subsubsection{compress\_us}
\label{table:compressUsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 6 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Compress, unsigned with saturation.
\vspace{2mm}

Same as compress (see page \pageref{table:compressInstruction}). Integers are treated as unsigned and compressed with saturation. Floating point operands cannot be used.
Masks cannot be used and overflow traps cannot be enabled for this instruction.
\vspace{2mm}


\subsubsection{div\_oc}
\label{table:divOcInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 42 & vector registers. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Divide signed integers or floating point numbers with overflow check.

See add\_oc for options.

\subsubsection{mul\_oc}
\label{table:mulOcInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 41 & vector registers. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Multiply integers with overflow check.

See add\_oc for options.

\subsubsection{mul\_ss}
\label{table:mulSsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 34 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Multiply signed integers with saturation.

Overflow and underflow produces INT\_MAX and INT\_MIN.

\subsubsection{mul\_us}
\label{table:mulUsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 35 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Multiply unsigned integers with saturation.

Overflow produces UINT\_MAX.

\subsubsection{sub\_b}
\label{table:subBInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 29 & integer vectors with two elements. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Subtraction with borrow.
\vspace{2mm}

The vector has two elements. The upper element of src1 is used as borrow in. The upper element of dest is used as borrow out. Only the lower element of src2 is used.
\vspace{2mm}

Longer vectors are not supported. See page 
\pageref{highPrecisionArithmetic} for an alternative for longer vectors.

\subsubsection{sub\_oc}
\label{table:subOcInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 39 & vector registers. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Subtract integers with overflow check.

See add\_oc for options.

\subsubsection{sub\_ss}
\label{table:subSsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 32 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Subtract signed integers with saturation.

Overflow and underflow produces INT\_MAX and INT\_MIN.

\subsubsection{sub\_us}
\label{table:subUsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 33 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

Subtract unsigned integers with saturation.

Overflow and underflow produces UINT\_MAX and 0.


\subsection{Logic and bit manipulation instructions}

\subsubsection{and}
\label{table:andInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 28 & all types \\ \hline
tiny  & 11 & two g.p. registers \\ \hline
1.1 C & 18 & g.p. register and 8-bit signed constant shifted left by another constant \\ \hline
2.9   &  5 & g.p. register and 32-bit constant shifted left by 32 \\ \hline
1.3 C & 34 & vector of 16-bit integers, and broadcast 16-bit constant. Optional \\ \hline
1.3 C & 44 & vector of 32-bit integers, and broadcast sign-extended 8-bit constant shifted left by another constant. Optional \\ \hline
1.3 C & 45 & vector of 64-bit integers, and broadcast sign-extended 8-bit constant shifted left by another constant. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = r1 \& r2 \\
int32 v0 = v1 \& 2
\vspace{2mm}

Bitwise boolean and.
\vspace{2mm}

Floating point operands are treated as integers.

Do not use a floating point type with a constant operand unless you want the operand to be interpreted as floating point.

\subsubsection{and\_bit}
\label{table:andBitInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 39 & all types \\ \hline
\end{tabular}
\vspace{2mm}

Clear all bits except one. 
\vspace{2mm}

dest = src1 \& (1 $<<$ src2).

\vspace{2mm}
Floating point operands are treated as integers.

\vspace{2mm}
This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.
\vspace{2mm}

\subsubsection{and\_not}
\label{table:andNotInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 29 & all types \\ \hline
\end{tabular}
\vspace{2mm}

Bitwise and not.

dest = src1 \& \~{}src2
\vspace{2mm}

Floating point operands are treated as integers.

\subsubsection{bit\_reverse byte\_reverse}
\label{table:bitReverseInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 20 & vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = byte\_reverse(v1, 0)\\
int32 v0 = bit\_reverse(v1, 1)
\vspace{2mm}

IM1 = 0: Reverse the order of bytes within each vector element. This is useful for converting big-endian file data.\\
IM1 = 1: Reverse the order of bits in each element of a vector.
\vspace{2mm}


\subsubsection{bits2bool}
\label{table:bits2boolInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 12 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = bits2bool(r1, v2)
\vspace{2mm}

Expand contiguous bits in a vector register to a boolean vector with each bit of the source going into bit 0 of each element of the destination. 
The remaining bits of each element are copied from the first element of the mask or the numeric control register.
The length in bytes of the result vector is specified by a general purpose register in RS.
\vspace{2mm}

This instruction cannot have a fallback register.

\subsubsection{bitscan}
\label{table:bitscanInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B &  2 & general purpose registers \\ \hline
1.3 B & 21 & integer vectors. Optional for more than one element \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = bitscan(r1, 0)\\
int64 v0 = bitscan(v1, 1)
\vspace{2mm}

Bit scan forward or reverse. Option bits are given in the second operand:
\vspace{2mm}

\label{table:bitscanOptions}
\begin{tabular}{|p{16mm}|p{122mm}|}
\hline
\bfseries IM1 bits & \bfseries meaning \\ \hline
bit 0 & 0: forward scan. Find index to the lowest set bit.\newline
        1: reverse scan. Find index to the highest set bit.\\
\hline
bit 2 & 0: returns 0 if the input is 0.\newline
        1: returns -1 if the input is 0.\\ \hline
\end{tabular}
\vspace{2mm}


\subsubsection{bool\_reduce}
\label{table:boolReduceInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 14 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = bool\_reduce(r1, v2)
\vspace{2mm}

The boolean vector RT with length RS bytes is reduced by combining bit 0 of all elements.

The output is a scalar integer where bit 0 is the AND combination of all the bits, and bit
1 is the OR combination of all the bits. The remaining bits are reserved for future use.
\vspace{2mm}

This instruction cannot have a mask.


\subsubsection{bool2bits}
\label{table:bool2bitsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 13 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

int64 v0 = bool2bits(r1, v2)
\vspace{2mm}

The boolean vector RT with length RS bytes is packed into the lower n bits of RD, taking bit 0 of each element, where n is the number of elements (n = RS / OS). 
The length of RD will be at least sufficient to contain n bits.
\vspace{2mm}

This instruction cannot have a mask.
\vspace{2mm}

\subsubsection{category\_reduce}
\label{table:categoryReduceInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 14 & floating point vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = category\_reduce(r1, v2)
\vspace{2mm}

The floating point vector RT with length RS bytes is analyzed and each element is classified as belonging to one of the eight categories listed below. Each bit in the output indicates that at least one element in RT belongs to the corresponding category.
\vspace{2mm}

\begin{tabular}{|p{24mm}|p{115mm}|}
\hline
\bfseries Bit number & \bfseries Category \\ \hline
0 & at least one element is NAN \\
1 & at least one element is zero \\
2 & at least one element is negative subnormal \\
3 & at least one element is positive subnormal \\
4 & at least one element is negative normal \\
5 & at least one element is positive normal \\
6 & at least one element is negative infinity \\
7 & at least one element is positive infinity \\
\hline
\end{tabular}
\vspace{2mm}

The result can be tested with a conditional branch such as and\_jumpzero, test\_bit\_jumpzero, or test\_jump\_all1.
\vspace{2mm}

This instruction cannot have a mask.

\subsubsection{clear\_bit}
\label{table:clearBitInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 37 & all types \\ \hline
\end{tabular}
\vspace{2mm}

Clear bit number src2 in src1.
\vspace{2mm}

dest = src1 \& \~{}(1 $<<$ src2).

\vspace{2mm}
Floating point operands are treated as integers.

\vspace{2mm}
This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.
\vspace{2mm}

\subsubsection{compare}
See page \pageref{table:compareInstruction}
\vspace{2mm}

\subsubsection{fp\_category}
\label{table:fpCategoryInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 17 & floating point vectors \\ \hline
\end{tabular}
\vspace{2mm}

float v0 = fp\_category(v1, 1)
\vspace{2mm}

The input is a floating point vector. The output is a boolean vector where bit 0 of each element indicates if the input RS belongs to any of the categories indicated by the bits in the immediate operand IM1. The remaining bits of the output are taken from the numeric control register. 
Any floating point value will belong to one, and only one, of these categories. 

\begin{longtable} {|p{20mm}|p{90mm}|}
\caption{Meaning of bits in fp\_category} 
\label{table:fpCategoryInstructionBits} \\
\endfirsthead
\endhead
\hline
\bfseries Bit number & \bfseries Meaning  \\
\hline
0 & $\pm$ NAN \\
1 & $\pm$ Zero \\
2 & $-$ Subnormal \\
3 & $+$ Subnormal \\
4 & $-$ Normal \\
5 & $+$ Normal \\
6 & $-$ Infinite  \\
7 & $+$ Infinite  \\
\hline
\end{longtable}

\subsubsection{make\_mask}
\label{table:makeMaskInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.6 &  2 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = make\_mask(v1, 2)
\vspace{2mm}

Make a mask from the bits of the 32-bit integer constant src2. Each bit of src2 goes into bit 0 of one element of the output. The remaining bits of each element are taken from src1. The length of the output is the same as the length of src1. If there are more than 32 elements in the vector then the bit pattern of src2 is repeated.

\subsubsection{make\_sequence}
\label{table:makeSequenceInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B &  4 & all vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = make\_sequence(r1, 2)
\vspace{2mm}

Makes a vector of RS sequential numbers. 
The first element is equal to IM1, the next element is IM1+1, etc.

\subsubsection{mask\_length}
\label{table:maskLengthInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.2.7 & 1.1 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

int64 v0 = mask\_length(r1, v2, 0), options=2
\vspace{2mm}

Make a boolean vector to mask the first n bytes of a vector (RS = n). \\
The output vector RD will have the same length as the input vector RT. RS indicates the length of the part that is enabled by the mask. 
\vspace{2mm}

IM3 contains the following option bits: \\
bit 0 = 0: bit 0 will be 1 in the first n bytes in the output and 0 in the rest. \\
bit 0 = 1: bit 0 will be 0 in the first n bytes in the output and 1 in the rest. \\
bit 1 = 1: copy remaining bits from input vector RT into each vector element. \\
bit 2 = 1: copy remaining bits from the numeric control register. \\
bit 4 = 1: broadcast remaining bits from IM2 into all 32-bit words of RD. \\
\hspace{17mm} Bit 1-7 of IM2 go to bit 1-7 of RD. \\
\hspace{17mm} Bit 8-11 of IM2 go to bit 20-23 of RD. \\
\hspace{17mm} Bit 12-15 of IM2 go to bit 26-29 of RD. \\
Output bits that are not set by any of these options will be zero. 
If multiple options are specified, the results will be OR'ed.

\vspace{2mm}
This instruction can have a mask but not a fallback register. The fallback value is zero.


\subsubsection{move\_bits}
\label{table:moveBitsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.0.7 & 0.1 & general purpose registers. Optional \\ \hline
2.2.7 & 0.1 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = move\_bits(v1, v2, 3, 4, 5) 
\vspace{2mm}

Take one or more contiguous bits from one position in the second source operand and insert them into another position the first source operand. This can be used for all kinds of bitfield operations.
\vspace{2mm}

The position in src2 is the lower 8 bits of IM2. a = IM2 \& 0xFF.

The position in src1 is the upper 8 bits of IM2. b = IM2 $>>$ 0xFF.

The number of bits to move is c = IM3.
\vspace{2mm}

m = (1 $<<$ c) - 1

dest = (src1 \& \~{}(m$<<$b)) $|$ ((src2 $>>$ a) \& m) $<<$ b

\subsubsection{or}
\label{table:orInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 30 & all types \\ \hline
tiny  & 12 & two g.p. registers \\ \hline
1.1 C & 19 & g.p. register and 8-bit signed constant shifted left by another constant \\ \hline
2.9   &  6 & g.p. register and 32-bit constant shifted left by 32 \\ \hline
1.3 C & 35 & vector of 16-bit integers, and broadcast 16-bit constant. Optional \\ \hline
1.3 C & 46 & vector of 32-bit integers, and broadcast sign-extended 8-bit constant shifted left by another constant. Optional \\ \hline
1.3 C & 47 & vector of 64-bit integers, and broadcast sign-extended 8-bit constant shifted left by another constant. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = r1 $|$ r2 \\
int32 v0 = v1 $|$ 2
\vspace{2mm}

Bitwise boolean or.
\vspace{2mm}

Floating point operands are treated as integers.

Do not use a floating point type with a constant operand unless you want the operand to be interpreted as floating point.


\subsubsection{popcount}
\label{table:popcountInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B &  4 & general purpose registers \\ \hline
1.3 B & 22 & integer vectors. Optional for more than one element \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = popcount(v1)
\vspace{2mm}

The popcount instruction counts the number of 1-bits in an integer. It can also be used for parity generation.
\vspace{2mm}


\subsubsection{replace\_bits}
\label{table:replaceBitsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.9 & 9 & general purpose registers. Optional \\ \hline
2.6 & 9 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = replace\_bits(v1, 2, 3, 4) 
\vspace{2mm}

Replace one or more contiguous bits in the first source operand with a constant.\\
The second source operand is the replacement bits, with a maximum size of 16 bits. (Any additional bits will be zero)\\
The third source operand is the position of the bits to replace.\\
The fourth source operand is the number of bits to replace.
\vspace{2mm}

Algorithm:\\
val = IM2 \& 0xFFFF\\
pos = (IM2 $>>$ 16) \& 0xFF\\
num = (IM2 $>>$ 24) \& 0xFF\\
mask = (1 $<<$ num) - 1\\

dest = (src1 \& \~{}(mask$<<$pos)) $|$ ((val \& mask) $<<$ pos)
\vspace{2mm}


\subsubsection{rotate}
\label{table:rotateInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 33 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

Rotate the bits of src1 left if src2 is positive, or right if src2 is negative.

\vspace{2mm}
This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.
\vspace{2mm}

\subsubsection{set\_bit}
\label{table:setBitInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 36 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

Set bit number src2 in src1 to one.
\vspace{2mm}

dest = src1 $|$ (1 $<<$ src2)

\vspace{2mm}
This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.
\vspace{2mm}


\subsubsection{test\_bit}
\label{table:testBitInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 40 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

Test the value of bit number src2 in src1, and make it the least significant bit of the output (to use as a boolean). The result is zero if src2 is out of range.
\vspace{2mm}

result = (src1 $>>$ src2) \& 1.
\vspace{2mm}

The remaining bits of the output are taken from a mask or from the numeric control register if there is no mask. 

\vspace{2mm}
This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.

\vspace{2mm}
Masking and fallback is possible. Alternative use of the mask register and the fallback register as extra boolean operands is supported with E template formats with no memory operand. These options are controlled by bit 0-1 of the constant IM3 in the same way as for the compare instruction (see page \pageref{table:AlternativeFallbackForCompare}). Bit 2 inverts the result, bit 3 inverts the fallback, and bit 4 inverts the mask. These options are summarized in the following table, giving the value of bit 0 of the destination register. These options cannot be used if there is a memory operand.

\begin{longtable} {|p{10mm}|p{10mm}|p{10mm}|p{10mm}|p{10mm}|p{60mm}|}
\caption{Alternative use of mask and fallback register controlled by IM3} 
\label{table:AlternativeMaskUseForTestBit} \\
\endfirsthead
\endhead
\hline
\bfseries bit 4 & \bfseries bit 3 & \bfseries bit 2 & \bfseries bit 1 & \bfseries bit 0 & \bfseries Output \\
\hline
0 & 0 & 0 & 0 & 0 & mask ? result : fallback \\
0 & 0 & 1 & 0 & 0 & mask ? !result : fallback \\
0 & 1 & 0 & 0 & 0 & mask ? result : !fallback \\
0 & 1 & 1 & 0 & 0 & mask ? !result : !fallback \\
1 & 0 & 0 & 0 & 0 & !mask ? result : fallback \\
1 & 0 & 1 & 0 & 0 & !mask ? !result : fallback \\
1 & 1 & 0 & 0 & 0 & !mask ? result : !fallback \\
1 & 1 & 1 & 0 & 0 & !mask ? !result : !fallback \\
\hline
0 & 0 & 0 & 0 & 1 & mask \& result \& fallback \\
0 & 0 & 1 & 0 & 1 & mask \& !result \& fallback \\
0 & 1 & 0 & 0 & 1 & mask \& result \& !fallback \\
0 & 1 & 1 & 0 & 1 & mask \& !result \& !fallback \\
1 & 0 & 0 & 0 & 1 & !mask \& result \& fallback \\
1 & 0 & 1 & 0 & 1 & !mask \& !result \& fallback \\
1 & 1 & 0 & 0 & 1 & !mask \& result \& !fallback \\
1 & 1 & 1 & 0 & 1 & !mask \& !result \& !fallback \\
\hline
0 & 0 & 0 & 1 & 0 & mask \& (result $|$ fallback) \\
0 & 0 & 1 & 1 & 0 & mask \& (!result $|$ fallback) \\
0 & 1 & 0 & 1 & 0 & mask \& (result $|$ !fallback) \\
0 & 1 & 1 & 1 & 0 & mask \& (!result $|$ !fallback) \\
1 & 0 & 0 & 1 & 0 & !mask \& (result $|$ fallback) \\
1 & 0 & 1 & 1 & 0 & !mask \& (!result $|$ fallback) \\
1 & 1 & 0 & 1 & 0 & !mask \& (result $|$ !fallback) \\
1 & 1 & 1 & 1 & 0 & !mask \& (!result $|$ !fallback) \\
\hline
0 & 0 & 0 & 1 & 1 & mask \& (result \^{} fallback) \\
0 & 0 & 1 & 1 & 1 & mask \& (!result \^{} fallback) \\
0 & 1 & 0 & 1 & 1 & mask \& (result \^{} !fallback) \\
0 & 1 & 1 & 1 & 1 & mask \& (!result \^{} !fallback) \\
1 & 0 & 0 & 1 & 1 & !mask \& (result \^{} fallback) \\
1 & 0 & 1 & 1 & 1 & !mask \& (!result \^{} fallback) \\
1 & 1 & 0 & 1 & 1 & !mask \& (result \^{} !fallback) \\
1 & 1 & 1 & 1 & 1 & !mask \& (!result \^{} !fallback) \\
\hline
\end{longtable}
\vspace{2mm}


\subsubsection{test\_bits}
\label{table:testBitsInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 41 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

Test if at least one of the indicated bits is 1.
The boolean result is placed in the least significant bit of the output. The remaining bits of the output are taken from a mask or from the numeric control register if there is no mask.
\vspace{2mm}

result = ((src1 \& src2) != 0)

\vspace{2mm}
Masking and fallback is possible. Alternative use of the mask register and the fallback register as extra boolean operands is supported with E template formats with no memory operand. These options are controlled by the bits of IM3 in the same way as for test\_bit, as indicated in table \ref{table:AlternativeMaskUseForTestBit}.

\subsubsection{test\_bits\_all1}
\label{table:testBitsAll1Instruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 42 & all integer types \\ \hline
\end{tabular}
\vspace{2mm}

Test if all the indicated bits are 1.
The boolean result is placed in the least significant bit of the output. The remaining bits of the output are taken from a mask or from the numeric control register if there is no mask.
\vspace{2mm}

result = ((src1 \& src2) == src2)

\vspace{2mm}
Masking and fallback is possible. Alternative use of the mask register and the fallback register as extra boolean operands is supported with E template formats with no memory operand. These options are controlled by the bits of IM3 in the same way as for test\_bit, as indicated in table \ref{table:AlternativeMaskUseForTestBit}.

\subsubsection{toggle\_bit}
\label{table:toggleBitInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 38 & all types \\ \hline
\end{tabular}
\vspace{2mm}

Change the value of bit number src2 in src1 to its opposite.
\vspace{2mm}

dest = src1 \^{} (1 $<<$ src2)

\vspace{2mm}
This instruction can have a memory operand and an immediate operand, using an E template format and IM3  as the immediate operand. It is not possible to have both a register operand and a memory operand with these formats.
\vspace{2mm}


\subsubsection{truth\_tab2}
\label{table:truthTab2Instruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 25 & integer vectors \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = truth\_tab2(v0, v1, 8)
\vspace{2mm}

This instruction can make an arbitrary boolean function of two boolean vector input variables, expressed by a 4-bit truth table in an immediate constant IM1. The result in bit 0 of each vector element is the arbitrary boolean function of bit 0 of the corresponding elements of each of the input operands. Bit 0 of the result is a bit from the truth table selected by the combined input bits. The remaining bits of the output vector are copied from the first input operand. 
\vspace{2mm}

The first source operand must be the same as the destination operand.
\vspace{2mm}

This instruction can be used as a universal instruction for manipulating and combining boolean vectors and masks.
\vspace{2mm}

result = ((IM1 $>>$ ((src1 \& 1) $|$ (src2 \& 1) $<<$ 1)) \& 1) $|$ (src1 \& \~{}1)

\subsubsection{truth\_tab3}
\label{table:truthTab3Instruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.2.6 & 8.1 & integer vectors. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 v0 = truth\_tab3(v1, v2, v3, 9), options=0
\vspace{2mm}

This instruction can make an arbitrary boolean function of three boolean vector input variables, expressed by an 8-bit truth table in an immediate constant IM2. The result in bit 0 of each vector element is the arbitrary boolean function of bit 0 of the corresponding elements of each of the input operands. Bit 0 of the result is a bit from the truth table selected by the combined input bits. The remaining bits of the output vector are copied from the mask, or from the first input operand if there is no mask.
\vspace{2mm}

This instruction can be used as a universal instruction for manipulating and combining boolean vectors and masks.
\vspace{2mm}

Algorithm:\\
select = (src1 \& 1) $|$ (src2 \& 1) $<<$ 1 $|$ (src3 \& 1) $<<$ 2) \\
dest = (IM2 $>>$ select) \& 1 \\
The remaining bits of dest are determined by bit 1-4 of the option bits as described below.
\vspace{2mm}

IM3 contains the following option bits: \\
bit 0 = 0: Normal use of mask with src1 as fallback. \\
bit 0 = 1: The normal function of the mask is disabled. Instead, bit 0 of the result is AND'ed with the corresponding mask bit. \\
bit 1 = 1: copy remaining bits from input vector src1. \\
bit 2 = 1: copy remaining bits from the numeric control register. \\
bit 3 = 1: copy remaining bits from mask register. \\
bit 4 = 1: broadcast remaining bits from IM2 into all 32-bit words of RD. 
           Bit 8-11 of IM2 go to bit 20-23 of dest. Bit 12-15 of IM2 go to bit 26-29 of RD. \\
Output bits that are not set by any of these options will be zero. 
If multiple options are specified, the results will be OR'ed.


\subsubsection{xor}
\label{table:xorInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 31 & all types \\ \hline
tiny  & 13 & two g.p. registers \\ \hline
1.1 C & 20 & g.p. register and 8-bit signed constant shifted left by another constant \\ \hline
2.9   &  7 & g.p. register and 32-bit constant shifted left by 32 \\ \hline
1.3 C & 36 & vector of 16-bit integers, and broadcast 16-bit constant. Optional \\ \hline
1.3 C & 48 & vector of 32-bit integers, and broadcast sign-extended 8-bit constant shifted left by another constant. Optional \\ \hline
1.3 C & 49 & vector of 64-bit integers, and broadcast sign-extended 8-bit constant shifted left by another constant. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 r0 = r1 \^{} r2 \\
int32 v0 = v1 \^{} 2
\vspace{2mm}

Bitwise boolean exclusive or.
\vspace{2mm}

Floating point operands are treated as integers.

Do not use a floating point type with a constant operand unless you want the operand to be interpreted as floating point.
\vspace{2mm}


\subsection{Combined ALU and branch instructions with integer operands}
\label{descriptionOfControlTransferInstructions}
These instructions are doing an arithmetic or logic operation and a conditional jump
depending on the result. Each instruction can be coded in a number of different formats
described on page \pageref{table:jumpInstructionFormats}.
\vspace{2mm}

The instructions are listed below in pairs, where the second instruction has the branch condition inversed.
\vspace{2mm}

These instructions cannot have a mask. The following conditions may generate traps in combined ALU and branch instructions if enabled by certain bits in the numeric control register: \\
\hspace{5mm} Unsigned integer overflow (bit 6), \\
\hspace{5mm} Signed integer overflow (bit 7), \\
\hspace{5mm} NAN inputs to compare (bit 29).\\
Note that support for traps in these instructions is optional.
\vspace{2mm}

Addition and subtraction instructions here do not support floating point operands because the longer latency will not fit into the pipeline structure. The codes that floating point add/sub-jump instructions would have are used for other purposes instead.
\vspace{2mm}

Conditional jump instructions cannot have a memory operand. Conditional jump instructions can have a constant operand if it fits into 32 bits or less.
\vspace{2mm}


\subsubsection{add/jump\_zero}
\label{table:addJumpZeroInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 16 & add/jump\_zero & integer \\ \hline
all & 17 & add/jump\_nzero & integer\\ \hline
\end{tabular}
\vspace{2mm}

Add two integer operands and jump if the result is zero.


\subsubsection{add/jump\_neg}
\label{table:addJumpNegInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 18 & add/jump\_neg & integer \\ \hline
all & 19 & add/jump\_nneg & integer\\ \hline
\end{tabular}
\vspace{2mm}

Add two integer operands and jump if the signed result is negative.

The result will wrap around in the case of overflow and jump if the result has the sign bit set.


\subsubsection{add/jump\_pos}
\label{table:addJumpPosInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 20 & add/jump\_pos & integer \\ \hline
all & 21 & add/jump\_npos & integer\\ \hline
\end{tabular}
\vspace{2mm}

Add two integer operands and jump if the signed result is positive.

The result will wrap around in the case of overflow and jump if the result is not zero and does not have the sign bit set.


\subsubsection{add/jump\_overfl}
\label{table:addJumpOverflInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 22 & add/jump\_overfl & integer \\ \hline
all & 23 & add/jump\_noverfl & integer\\ \hline
\end{tabular}
\vspace{2mm}

Add two signed integer operands and jump if the result overflows.
\vspace{2mm}

This instruction will not generate traps in case of signed or unsigned overflow, regardless of  NUMCONTR.
\vspace{2mm}


\subsubsection{add/jump\_carry}
\label{table:addJumpCarryInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 24 & add/jump\_carry & integer \\ \hline
all & 25 & add/jump\_ncarry & integer\\ \hline
\end{tabular}
\vspace{2mm}

Add two unsigned integer operands and jump if the operation produces a carry.
\vspace{2mm}

This instruction will not generate traps in case of signed or unsigned overflow, regardless of  NUMCONTR.
\vspace{2mm}


\subsubsection{add/jump}
\label{table:addJumpInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 55 & add/jump & integer \\ \hline
\end{tabular}
\vspace{2mm}

Add two integer operands and jump unconditionally.

\subsubsection{increment\_compare/jump\_above}
\label{table:addJumpInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 50 & increment\_compare/jump\_above & integer \\ \hline
all & 51 & increment\_compare/jump\_beloweq & integer \\ \hline
\end{tabular}
\vspace{2mm}

Add 1 to the first source operand and jump if the signed result is bigger than the second source operand. The result is saved in the destination operand. This is useful for implementing a simple ``for'' loop.
\vspace{2mm}

The result will wrap around from INT\_MAX to INT\_MIN in case of overflow, and jump only if the second source operand is also INT\_MAX. This instruction will not generate traps in case of signed or unsigned overflow, regardless of NUMCONTR.
\vspace{2mm}

\vspace{2mm}

The hardware implementation can use the following algorithm to avoid problems with overflow and to minimize the latency:

dest = src1 + 1

jump if src1 $\geq$ src2
\vspace{2mm}

Note that a ``for'' loop using this instruction will stop at n, where n = src2. If it is desired to stop at n-1 then subtract 1 from n first. (An implementation that stops at n-1 would be more difficult to implement with a short latency).

\subsubsection{sub/jump\_zero}
\label{table:subJumpZeroInstruction}
\begin{tabular}{|p{20mm}|p{12mm}|p{56mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
1.4 B, 2.5.0 &  0 & sub/jump\_zero & integer \\ \hline
1.4 B, 2.5.0 &  1 & sub/jump\_nzero  & integer\\ \hline
\end{tabular}
\vspace{2mm}

Subtract two integer operands and jump if the result is zero.
\vspace{2mm}

Immedate constants are not allowed, and the corresponding format is used for other purposes.
If a constant operand is needed then change the sign of the operand and use add/jump\_zero. 

\subsubsection{sub/jump\_neg}
\label{table:subJumpNegInstruction}
\begin{tabular}{|p{20mm}|p{12mm}|p{56mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
1.4 B, 2.5.0 &  2 & sub/jump\_neg & integer \\ \hline
1.4 B, 2.5.0 &  3 & sub/jump\_nneg & integer\\ \hline
\end{tabular}
\vspace{2mm}

Subtract two integer operands and jump if the signed result is negative.

The result will wrap around in the case of overflow and jump if the result has the sign bit set.
\vspace{2mm}

Immedate constants are not allowed, and the corresponding format is used for other purposes.
If a constant operand is needed then change the sign of the operand and use add/jump\_neg. 

\subsubsection{sub/jump\_pos}
\label{table:subJumpPosInstruction}
\begin{tabular}{|p{20mm}|p{12mm}|p{56mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
1.4 B, 2.5.0 &  4 & sub/jump\_pos & integer \\ \hline
1.4 B, 2.5.0 &  5 & sub/jump\_npos & integer\\ \hline
\end{tabular}
\vspace{2mm}

Subtract two integer operands and jump if the signed result is positive.

The result will wrap around in the case of overflow and jump if the result is not zero and does not have the sign bit set.
\vspace{2mm}

Immedate constants are not allowed, and the corresponding format is used for other purposes.
If a constant operand is needed then change the sign of the operand and use add/jump\_pos. 

\subsubsection{sub/jump\_overfl}
\label{table:subJumpOverflInstruction}
\begin{tabular}{|p{20mm}|p{12mm}|p{56mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
1.4 B, 2.5.0 &  6 & sub/jump\_overfl & integer \\ \hline
1.4 B, 2.5.0 &  7 & sub/jump\_noverfl & integer\\ \hline
\end{tabular}
\vspace{2mm}

Subtract two signed integer operands and jump if the result overflows.
\vspace{2mm}

Immedate constants are not allowed, and the corresponding format is used for other purposes.
If a constant operand is needed then change the sign of the operand and use add/jump\_overfl. 
\vspace{2mm}

This instruction will not generate traps in case of signed or unsigned overflow, regardless of  NUMCONTR.
\vspace{2mm}

\subsubsection{sub/jump\_borrow}
\label{table:subJumpBorrowInstruction}
\begin{tabular}{|p{20mm}|p{12mm}|p{56mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
1.4 B, 2.5.0 &  8 & sub/jump\_borrow & integer \\ \hline
1.4 B, 2.5.0 &  9 & sub/jump\_nborrow & integer\\ \hline
\end{tabular}
\vspace{2mm}

Subtract two unsigned integer operands and jump if the operation produces a borrow.
\vspace{2mm}

Immedate constants are not allowed, and the corresponding format is used for other purposes.
If a constant operand is needed then change the sign of the operand and use add/jump\_nborrow. 
\vspace{2mm}

This instruction will not generate traps in case of signed or unsigned overflow, regardless of  NUMCONTR.
\vspace{2mm}

\subsubsection{sub/jump}
\label{table:subJumpInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 54 & sub/jump & integer \\ \hline
\end{tabular}
\vspace{2mm}

Subtract two integer operands and jump unconditionally.


\subsubsection{sub\_maxlen/jump\_pos}
\label{table:subMaxlenJumpPosInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
1.5 2.5.2 & 52 & sub\_maxlen/jump\_pos & int64 in g. p. register \\ \hline
1.5 2.5.2 & 53 & sub\_maxlen/jump\_npos & int64 in g. p. register \\ \hline
\end{tabular}
\vspace{2mm}

Subtract the maximum vector length (in bytes) from a general purpose register and jump if the result is positive.
The 8-bit immediate operand indicates the operand type for which the maximum vector length is obtained.
\vspace{2mm}

The register operand must be a 64-bit general purpose register.
\vspace{2mm}

This instruction makes it easy to implement the type of vector loop described on on page \pageref{vectorLoops}.
\vspace{2mm}

This instruction will not generate traps in case of signed or unsigned overflow, regardless of NUMCONTR.
\vspace{2mm}


\subsubsection{and/jump\_zero}
\label{table:andJumpZeroInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 26 & and/jump\_zero & all \\ \hline
all & 27 & and/jump\_nzero & all \\ \hline
\end{tabular}
\vspace{2mm}

Bitwise and. Jump if zero.
\vspace{2mm}

dest = src1 \& src2

jump if dest == 0
\vspace{2mm}

All operands are treated as integers. 
Floating point operands are treated as unsigned integer scalars in vector registers.
\vspace{2mm}

\subsubsection{or/jump\_zero}
\label{table:orJumpZeroInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 28 & or/jump\_zero & all \\ \hline
all & 29 & or/jump\_nzero & all \\ \hline
\end{tabular}
\vspace{2mm}

Bitwise or. Jump if zero.
\vspace{2mm}

dest = src1 $|$ src2

jump if dest == 0
\vspace{2mm}

All operands are treated as integers. 
Floating point operands are treated as unsigned integer scalars in vector registers.
\vspace{2mm}

\subsubsection{xor/jump\_zero}
\label{table:xorJumpZeroInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 30 & xor/jump\_zero & all \\ \hline
all & 31 & xor/jump\_nzero & all \\ \hline
\end{tabular}
\vspace{2mm}

Bitwise exclusive or. Jump if zero.
\vspace{2mm}

dest = src1 \^{ } src2

jump if dest == 0
\vspace{2mm}

All operands are treated as integers. 
Floating point operands are treated as unsigned integer scalars in vector registers.


\subsubsection{shift\_left/jump\_zero}
\label{table:shiftLeftJumpZeroInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
not 1.5 & 10 & shift\_left/jump\_zero & all \\ \hline
not 1.5 & 11 & shift\_left/jump\_nzero & all \\ \hline
\end{tabular}
\vspace{2mm}

Shift the first source operand left by the count of the second source operand. Jump if the result is zero.
\vspace{2mm}

dest = src1 $<<$ src2

Jump if dest == 0
\vspace{2mm}

Support for vector registers is optional.


\subsubsection{shift\_right\_u/jump\_zero}
\label{table:shiftRightUJumpZeroInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
not 1.5 & 12 & shift\_right\_u/jump\_zero & all \\ \hline
not 1.5 & 13 & shift\_right\_u/jump\_nzero & all \\ \hline
\end{tabular}
\vspace{2mm}

Shift the first source operand right by the count of the second source operand with zero extension (logical shift). Jump if the result is zero.
\vspace{2mm}

dest = src1 $<<$ src2

Jump if dest == 0
\vspace{2mm}

Support for vector registers is optional.


\subsubsection{rotate/jump\_carry}
\label{table:rotateJumpCarryInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
not 1.5 & 14 & rotate/jump\_carry & all \\ \hline
not 1.5 & 15 & rotate/jump\_ncarry & all \\ \hline
\end{tabular}
\vspace{2mm}

Rotate the bits of the first source operand by the count of the second source operand, left if positive or right if negative. Jump if the carry bit is 1.
\vspace{2mm}

The carry bit is the least significant bit of the result if the shift count is positive or zero, and the most significant bit of the result if the shift count is negative.
\vspace{2mm}

This instruction is useful for generating an arbitrary sequence of jump and not jump.
\vspace{2mm}

Support for vector registers is optional.


\subsubsection{test\_bit/jump\_zero}
\label{table:testBitJumpZeroInstruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 42 & test\_bit/jump\_zero & all \\ \hline
all & 43 & test\_bit/jump\_nzero & all \\ \hline
\end{tabular}
\vspace{2mm}

Test a single bit in the first source operand as indicated by the an index in the second source operand and jump if the indicated bit is 0. 
\vspace{2mm}

All operands are treated as unsigned integers. 

Floating point operands are treated as unsigned integer scalars in vector registers.
\vspace{2mm}

jump if ((src1 $>>$ src2) \& 1) == 0
\vspace{2mm}

The destination operand (if any) will be unchanged.

\subsubsection{test/jump\_all1}
\label{table:testJumpAll1Instruction}
\begin{tabular}{|p{16mm}|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries operands \\ \hline
all & 44 & test/jump\_all1 & all \\ \hline
all & 45 & test/jump\_nall1 & all \\ \hline
\end{tabular}
\vspace{2mm}

Bitwise test. Jump if the indicated bits are all 1.
\vspace{2mm}

jump if (src1 \& src2) == src2
\vspace{2mm}

Floating point operands are treated as integer scalars in vector registers.
\vspace{2mm}

The destination operand (if any) will be unchanged.


\subsection{integer compare and branch instructions}
int64 compare(r1, r2), jump\_equal target
\vspace{2mm}

Compare instructions have no destination operand. 
Overflow cannot occur.
\vspace{2mm}

\label{table:integerCompareJumpInstructions}
\begin{tabular}{|p{12mm}|p{60mm}|p{50mm}|}
\hline
\bfseries opcode & \bfseries instruction & \bfseries jump condition \\ \hline
32 & compare/jump\_equal & r1 = r2 \\ \hline
33 & compare/jump\_nequal  & r1 $\neq$ r2 \\ \hline
34 & compare/jump\_sbelow & r1 $<$ r2, signed \\ \hline
35 & compare/jump\_saboveeq & r1 $\geq$ r2, signed \\ \hline
36 & compare/jump\_sabove & r1 $>$ r2, signed  \\ \hline
37 & compare/jump\_sbeloweq  & r1 $\leq$ r2, signed \\ \hline
38 & compare/jump\_ubelow & r1 $<$ r2, unsigned \\ \hline
39 & compare/jump\_uaboveeq  & r1 $\geq$ r2, unsigned \\ \hline
40 & compare/jump\_uabove & r1 $>$ r2, unsigned \\ \hline
41 & compare/jump\_ubeloweq  & r1 $\leq$ r2, unsigned \\ \hline
\end{tabular}
\vspace{2mm}


\subsection{floating point compare and branch instructions}
double compare(v1, v2), jump\_equal target
\vspace{2mm}

Compare instructions have no destination operand. 
Overflow cannot occur. \\
0.0 and -0.0 are treated as equal.
\vspace{2mm}

The unordered versions of floating point compare instructions are needed because conditions are often inversed in the compilation process. For example the inverse of compare/jump\_below is not compare/jump\_aboveeq but compare/jump\_aboveeq\_uo. This is a consequence of the standard rule that all comparisons return false when the inputs are unordered, i.e. when at least one operand is NAN.
\vspace{4mm}

\label{table:floatCompareJumpInstructions}
\begin{tabular}{|p{12mm}|p{60mm}|p{50mm}|p{25mm}|}
\hline
\bfseries opcode & \bfseries instruction & \bfseries jump condition & \bfseries NAN input \\ \hline
32 & compare/jump\_equal & v1 = v2 & no jump \\ \hline
16 & compare/jump\_equal\_uo & v1 = v2 & jump \\ \hline
33 & compare/jump\_nequal  & r1 $\neq$ r2 & no jump \\ \hline
17 & compare/jump\_nequal\_uo  & r1 $\neq$ r2 & jump \\ \hline
34 & compare/jump\_below & r1 $<$ r2 & no jump  \\ \hline
18 & compare/jump\_below\_uo & r1 $<$ r2 & jump  \\ \hline
35 & compare/jump\_aboveeq & r1 $\geq$ r2 & no jump  \\ \hline
19 & compare/jump\_aboveeq\_uo & r1 $\geq$ r2 & jump  \\ \hline
36 & compare/jump\_above & r1 $>$ r2 & no jump   \\ \hline
20 & compare/jump\_above\_uo & r1 $>$ r2 & jump   \\ \hline
37 & compare/jump\_beloweq  & r1 $\leq$ r2 & no jump  \\ \hline
21 & compare/jump\_beloweq\_uo  & r1 $\leq$ r2 & jump  \\ \hline
38 & compare/jump\_infinite & one or both is $\infty$ &  no jump, \newline no exception \\ \hline
22 & compare/jump\_infinite\_uo & one or both is $\infty$ & jump, \newline no exception  \\ \hline
39 & compare/jump\_finite & none is $\infty$ &  no jump, \newline no exception \\ \hline
23 & compare/jump\_finite\_uo & none is $\infty$ & jump, \newline no exception \\ \hline
40 & compare/jump\_ordered & none is NAN & no jump, \newline no exception \\ \hline
41 & compare/jump\_unordered & one or both is NAN & jump, \newline no exception \\ \hline
\end{tabular}
\vspace{2mm}

The last six instructions will not generate exceptions for NAN inputs, even if bit 29 in NUMCONTR is set.


\subsection{Unconditional and indirect jump, call, and return instructions}
Control transfer instructions are available in a number of different formats, described on 
page \pageref{table:jumpInstructionFormats}.


\subsubsection{Direct jump}
\label{table:jumpInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.5 C & 58 & jump with 16 bit relative address \\ \hline
1.5 D &  0 & jump with 24 bit relative address \\ \hline
2.5.2 C & 58 & jump with 32 bit relative address \\ \hline
3.1.0 B & 58 & jump with 64 bit absolute address \\ \hline
\end{tabular}
\vspace{2mm}

Unconditional jump.


\subsubsection{Direct function call}
\label{table:callInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.5 C & 59 & call with 16 bit relative address \\ \hline
1.5 D &  8 & call with 24 bit relative address \\ \hline
2.5.2 C & 59 & call with 32 bit relative address \\ \hline
3.1.0 B & 59 & call with 64 bit absolute address \\ \hline
\end{tabular}
\vspace{2mm}

Function call.
\vspace{2mm}

The return address is stored on the call stack. The calling conventions are described in chapter \ref{chap:functionCallingConventions}.


\subsubsection{Indirect jump}

\label{table:indirectJumpInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.4 B & 58 & 64 bit absolute address in memory operand with 8 bit offset \\ \hline
2.5.0 B & 58 & 64 bit absolute address in memory operand with 32 bit offset \\ \hline
1.5 C & 60 & 64 bit absolute address in register \\ \hline
1.4 A & 60 & Multi-way jump with table of relative addresses (see below) \\ \hline
\end{tabular}
\vspace{2mm}


\subsubsection{Indirect call}
\label{table:IndirectCallInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.4 B & 59 & 64 bit absolute address in memory operand with 8 bit offset \\ \hline
2.5.0 B & 59 & 64 bit absolute address in memory operand with 32 bit offset \\ \hline
1.5 C & 61 & 64 bit absolute address in register \\ \hline
1.4 A & 61 & Multi-way call with table of relative addresses (see below) \\ \hline\end{tabular}
\vspace{2mm}



\subsubsection{Multi-way jump and call}
\label{table:multiwayJumpCallInstructions}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.4 A   & 60 & Jump with table of relative addresses. \linebreak Has reference point, base and scaled index  \\ \hline
2.5.0 B & 60 & Jump with table of relative addresses. \linebreak Has reference point, base and offset  \\ \hline
1.4 A   & 61 & Call with table of relative addresses. \linebreak Has reference point, base and scaled index    \\ \hline
2.5.0 B & 61 & Call with table of relative addresses. \linebreak Has reference point, base and offset \\ \hline
\end{tabular}
\vspace{2mm}

\label{jumpTableInstruction}
The table-based indirect jump and call instructions are intended to facilitate multiway branches \\
(switch/case statements), function tables in code interpreters, and virtual function tables in object oriented languages with polymorphism. 
\vspace{2mm}

The table of jump or call addresses is stored in memory as signed offsets relative to an arbitrary reference point, which may be the table address, the ip\_base, or any other reference point. The operand type specifies the size of the table entries. The use of relative addresses makes the table more compact than if 64-bit absolute addresses were used.
\vspace{2mm}

This instruction works as follows. Calculate the address of a table entry as the base pointer (RT) plus the offset (unscaled) or the index (RS) multiplied by the operand size. Read a signed value from this address, sign-extend to 64 bits, and scale by 4. Then add the reference point (RD). Jump or call to the calculated address. The array index (RS) is scaled by the operand size, while the table entries are scaled by the instruction word size (4). The reference point must be aligned by 4.
\vspace{2mm}

The table used by the table-based jump and call instructions is preferably placed in the constant data section (CONST). This makes it possible to use the table base as reference point. This also improves security by giving read-only access to the table.
\vspace{2mm}

This instruction cannot have a mask and it will not generate overflow traps in case of overflow in the address calculation, but you will get access violation traps when attempting to access an illegal memory address.
\vspace{2mm}

\subsubsection{return}
\label{table:returnInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.4 B & 62 & \\ \hline
\end{tabular}
\vspace{2mm}

Return from function call. The return address is taken from the call stack.
\vspace{2mm}

Return instructions do not need a stack offset when the calling conventions specified in chapter \ref{chap:functionCallingConventions} are used.


\subsubsection{System call, system return, and traps}
See page \pageref{table:sysCallInstruction}.
\vspace{2mm}


\subsection{Miscellaneous instructions}

\subsubsection{address}
\label{table:addressInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.9 & 32 & g.p. registers \\ \hline
\end{tabular}
\vspace{2mm}

int64 r1 = address([memory\_label])
\vspace{2mm}

Calculate an address relative to a pointer by adding a 32-bit sign-extended constant to a special pointer register. The pointer register can be THREADP (28), DATAP (29), IP (30) or SP(31).
\vspace{2mm}

\subsubsection{compare\_swap}
\label{table:compareSwapInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
2.5 B & 18 & g. p. registers and memory operand with 32 bit offset. Optional \\ \hline
\end{tabular}
\vspace{2mm}

int32 r1 = compare\_swap(r1, r2, [r3+0x100])
\vspace{2mm}

Atomic compare and swap instruction, used for thread synchronization and for lock-free data sharing between threads. src1 and src2 are register operands, src3 is a memory operand, which must be aligned to a natural address. All operands are treated as integers, regardless of the specified operand type. The operation is:

\begin{lstlisting}[frame=none]
   temp = src3;
   if (temp == src1) src3 = src2;
   return temp;
\end{lstlisting}

This instruction cannot have a mask.
\vspace{2mm}

Further atomic instructions can be implemented if needed, preferably with the same format and consecutive values of OP1.

\subsubsection{filler}
\label{table:fillerInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.5 C & 63 & \\ \hline
\end{tabular}
\vspace{2mm}

This instruction is used for filling unused code memory. It will generate a trap (interrupt) if executed.
\vspace{2mm}

All fields are filled with ones. The complete instruction code word is 0x6FFFFFFF.

\subsubsection{nop}
\label{table:nopInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi &  0 & \\ \hline
tiny  &  0 & \\ \hline
3.0   &  0 & \\ \hline
\end{tabular}
\vspace{2mm}

No operation. Used as a filler to replace removed code or to align code entries.
\vspace{2mm}

The processor is allowed to skip NOPs as fast as it can at an early stage in the pipeline. A pair of tiny instructions where the second instruction is a NOP can be treated as a single instruction.
\vspace{2mm}

These NOPs cannot be used as timing delays, only as fillers.

\subsubsection{undef}
\label{table:undefInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 63 & \\ \hline
\end{tabular}
\vspace{2mm}

Undefined code. Guaranteed to generate trap (interrupt) in all future implementations

\subsubsection{userdef}
\label{table:userdefInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
multi & 55-62 & any types \\ \hline
\end{tabular}
\vspace{2mm}

Reserved for user-defined instructions.
\vspace{2mm}

\subsection{System instructions}
These instructions cannot have a mask.
\vspace{2mm}

\subsubsection{input}

\label{table:inputInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 62 & vector registers \\ \hline
\end{tabular}
\vspace{2mm}

int64 v0 = input(r1, r2)
\vspace{2mm}

Read from input port. Privileged instruction.
\vspace{2mm}

RD = destination (vector register),
RS = vector length in bytes, RT = port address.

\subsubsection{output}
\label{table:outputInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 63 & vector registers \\ \hline
\end{tabular}
\vspace{2mm}

int64 output(v0, r1, r2)
\vspace{2mm}

Write to output port. Privileged instruction.
\vspace{2mm}

RD = source (vector register),
RS = vector length in bytes, RT = port address.

\subsubsection{read\_capabilities}
\label{table:readCapabilitiesInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B & 34 & g.p. register, capabilities register \\ \hline
\end{tabular}
\vspace{2mm}

Read processor capabilities register. These registers are used for indicating capabilities of the processor, such as support for optional instructions and limitations to vector lengths. The size is 64 bits. These registers are initialized with their default values at program start.
\vspace{2mm}

The immediate constant in IM1 determines details of the operation:

\begin{longtable} {|p{20mm}|p{90mm}|}
\caption{Meaning of immediate constant in read\_capabilities and write\_capabilities instructions} 
\label{table:readWriteCapabilitiesModes} \\
\endfirsthead
\endhead
\hline
\bfseries Bit number & \bfseries Meaning  \\
\hline
0  &  0: read/write the capabilities for the operand type specified in bit 5-7.\newline
      1: read the typical capabilities for all operand types / write the capabilities for all    
      relevant operand types.  \\
\hline
1  &  0: read the current value of the register, which may have been modified.\newline
      1: read the real capabilities of the hardware (cannot write.) \\
\hline
5-7 & Operand type for capabilities. \\
\hline
\end{longtable}


\begin{longtable} {|p{20mm}|p{90mm}|}
\caption{List of capabilities registers} 
\label{table:capabilitiesRegisters} \\
\endfirsthead
\endhead
\hline
\bfseries Capabilities register number & \bfseries Meaning  \\
\hline
capab0  &  Maximum vector length for general instructions. \\
\hline
capab1  &  Maximum vector length for permute instructions. \\
\hline
capab2  &  Maximum block size for permute instructions. \\
\hline
capab3  &  Maximum vector length for compress\_sparse and expand\_sparse. \\
\hline
capab8  &  Support for optional instructions in general purpose registers. Each bit indicates a specific instruction. \\
\hline
capab9  &  Support for optional instructions on scalars in vector registers. Each bit indicates a specific instruction. \\
\hline
capab10 &  Support for optional instructions on vectors. Each bit indicates a specific instruction. \\
\hline
\end{longtable}

Changing the values of the maximum vector length has the following effects. If the maximum length is reduced below the physical capability then any attempt to make a longer vector will result in the reduced length. The behavior of vector registers that already had a longer length before the maximum length was reduced, is implementation dependent. If the maximum vector length is set to a higher value than the physical capability then any attempt to make a vector longer than the physical capability will cause a trap to facilitate emulation. Capabilities registers 0-3 can be increased for the purpose of emulation. The value of capabilities registers 0-3 must be powers of 2.
\vspace{2mm}

Capabilities registers 8-9 can be modified for test purposes or to tell the software not to use a specific instruction. The same value will be returned when reading the register. Attempts to execute an instruction that is not supported will cause a trap, regardless of the value of the capabilities register.

\subsubsection{read\_memory\_map}
\label{table:readMemoryMapInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 60 & memory map, vector register \\ \hline
\end{tabular}
\vspace{2mm}

int64 v0 = read\_memory\_map(r2, r3)
\vspace{2mm}

Read memory map and save it to a vector register. Privileged instruction.
\vspace{2mm}

RD = destination vector register, RT-RS = internal address.

\subsubsection{read\_call\_stack}
\label{table:readCallStackInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 58 & internal call stack, vector register \\ \hline
\end{tabular}
\vspace{2mm}

int64 v0 = read\_call\_stack(r1, r2)
\vspace{2mm}

Read the internal call stack into a vector register. This instruction is used for saving the internal call stack to system memory in case of overflow.
Privileged instruction.
\vspace{2mm}

RD = destination vector register, RT-RS = internal address.


\subsubsection{read\_perf}
\label{table:readPerfInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B & 36 & g.p. register, performance counter register \\ \hline
\end{tabular}
\vspace{2mm}

Read performance counter register. A number of internal registers are used for counting performance related events. The details are not defined yet.
\vspace{2mm}

This instruction has an integer constant as second source operand. This is reserved for future purposes and must be 0.


\subsubsection{read\_perfs}
\label{table:readPerfInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B & 37 & g.p. register, performance counter register \\ \hline
\end{tabular}
\vspace{2mm}

This is the same as the read\_perf instruction, but serializing. This means that no instruction can execute out of order with read\_perfs.

\vspace{2mm}

This instruction has an integer constant as second source operand. This is reserved for future purposes and must be 0.

\subsubsection{read\_spec}
\label{table:readSpecInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B & 32 & g.p. register, special register \\ \hline
\end{tabular}
\vspace{2mm}

int64 r0 = read\_spec(spec1, 2) \\
\vspace{2mm}

Read a special system register. The following special registers are currently defined. The size is 64 bits. These registers are initialized with their default values at program start.
\vspace{2mm}

This instruction has an integer constant as second source operand. This is reserved for future purposes and must be 0. This instruction cannot have a mask.

\begin{longtable} {|p{15mm}|p{100mm}|}
\caption{List of special registers} 
\label{table:specialRegisters} \\
\endfirsthead
\endhead
\hline
\bfseries Special register number & \bfseries Meaning  \\
\hline
spec0  & Numeric control register (NUMCONTR)  \\
spec1  & Microprocessor brand ID  \\
spec2  & Microprocessor version number   \\
spec28 & Thread environment block pointer (THREADP)   \\
spec29 & Data section pointer (DATAP)  \\
\hline
\end{longtable}

\subsubsection{read\_spev}
\label{table:readSpevInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.3 B & 2 & vector register, special register \\ \hline
\end{tabular}
\vspace{2mm}

int64 v0 = read\_spev(r1, 2)
\vspace{2mm}

Read special register IM1 into vector register RD with length RS bytes. The value is broadcast if the vector register is longer than the special register. 
\vspace{2mm}

The following special registers are currently defined:

\begin{longtable} {|p{15mm}|p{100mm}|}
\caption{Special registers that can be read into vectors} 
\label{table:specialVectorRegisters} \\
\endfirsthead
\endhead
\hline
\bfseries Special register number & \bfseries Meaning  \\
\hline
spec0 & Numeric control register (NUMCONTR). The value is broadcast into all elements of the destination register with the indicated operand size and length.  \\
\hline
spec1 & Name of processor. The output is a zero-terminated UTF-8 string containing the brandname and model name of the microprocessor. \\
\hline
\end{longtable}


\subsubsection{read\_sys}
\label{table:readSysInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B & 38 & g.p. register, system register \\ \hline
\end{tabular}
\vspace{2mm}

Read system register. Details are not defined yet. This instruction is privileged.

\vspace{2mm}

This instruction has an integer constant as second source operand. This is reserved for future purposes and must be 0.

\subsubsection{sys\_call}
\label{systemCallInstruction}
System calls use ID numbers rather than addresses to identify system functions. 
The ID is the combination of a module ID identifying a particular system module or device driver and a function ID identifying a particular function within this module. The module ID and the function ID are both 16 or 32 bits, so that the combined system call ID is up to 64 bits.
The sys\_call instruction has the following variants:

\begin{longtable}
{|p{20mm}|p{20mm}|p{20mm}|p{30mm}|p{30mm}|}
\caption{Variants of system call instruction}
\label{table:sysCallInstruction}
\endfirsthead
\endhead
\hline
Format & Operand type & Register operands & Module ID & Function ID \\
\hline
1.4 A & 32 bit & 3 & RT bit 16-31 & RT bit 0-15 \\
\hline
1.4 A & 64 bit & 3 & RT bit 32-63 & RT bit 0-31 \\
\hline
2.5.1 B & 32 bit & 2 & IM2 bit 16-31 & IM2 bit 0-15\\
\hline
2.5.4 C & 64 bit & 0  & IM3 bit 0-31 & IM1,IM2 bit 0-15 \\
\hline
3.1.0 B & 64 bit & 2  & IM3 bit 0-31 & IM2 bit 0-31 \\
\hline
\end{longtable}

The sys\_call instruction can indicate a block of memory to be shared with the system function. The address of the memory block is pointed to by the register specified in RD and the length is in register RS. This memory block, which the caller must have access rights to, is shared with the system function. The system function will get the same access rights to this block as the calling thread has, i. e. read access and/or write access. This is useful for fast transfer of data between the caller and the system function. No other memory is accessible to both the caller and the called function. If the RD and RS fields are both r0 then no memory block is shared. If RD and RS are both SP then all the application's data memory is shared. The sys\_call instruction in format 2.5.4 has no register operands and no shared memory block. System calls cannot have a mask.
\vspace{2mm}

Parameters for system functions are transferred in registers, following the same calling conventions as normal functions. The registers used for function parameters are usually different from the registers in the RD, RS and RT fields. Function parameters that do not fit into registers must reside in the shared memory block.


\subsubsection{sys\_return}
\label{table:sysCallInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.5 C & 62 & \\ \hline
\end{tabular}
\vspace{2mm}

Return from system call.

\subsubsection{trap}
\label{traps}
\label{table:trapInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{30mm}|p{80mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries immediate operand \\ \hline
1.5 C & 63 & trap & 0-254 \\ \hline
1.5 C & 63 & filler & 255 \\ \hline
\end{tabular}
\vspace{2mm}

Traps work like interrupts. The unconditional trap has an 8-bit interrupt number in IM1. This is an index into the interrupt vector table, which initially starts at absolute address zero. The unconditional trap instruction may use IM2 for additional information.  
\vspace{2mm}

A trap instruction with all 1's in all fields (opcode 0x6FFFFFFF) can be used as filler in unused parts of code memory.

\subsubsection{conditional trap}
\label{table:conditionalTrapInstructions}
\begin{tabular}{|p{12mm}|p{12mm}|p{30mm}|p{80mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries instruction & \bfseries immediate operand \\ \hline
2.5.3 C & 63 & compare, trap\_uabove & 40 \\ \hline
2.5.3 C & 63 & conditional trap & IM1 = interrupt number, IM2 = OPJ \\ \hline
\end{tabular}
\vspace{2mm}

The conditional trap generates a trap if the specified condition is true.\\
IM1 contains the interrupt number. \\
IM2 contains the condition code OPJ, specified in table  \ref{table:controlTransferInstructions}.
\vspace{2mm}

Currently, only the condition code 40 is supported, corresponding to compare unsigned and jump if above. This will generate a trap if RD $>$ IM3. This is useful for checking if an array index exceeds the upper bound. The lower bound does not have to be checked because we use unsigned compare. 


\subsubsection{write\_capabilities}
\label{table:writeCapabilitiesInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B & 35 & g.p. register, capabilities register \\ \hline
\end{tabular}
\vspace{2mm}

Write processor capabilities register. See the read\_capabilities instruction, page \pageref{table:readCapabilitiesInstruction}, for details.

\subsubsection{write\_memory\_map}
\label{table:writeMemoryMapInstruction}\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 61 & memory map, vector register \\ \hline
\end{tabular}
\vspace{2mm}

int64 write\_memory\_map(v1, r2, r3)
\vspace{2mm}

Write a vector register to memory map. RD = vector register source. RT-RS = internal address. Privileged instruction.
\vspace{2mm}

\subsubsection{write\_call\_stack}
\label{table:writeCallStackInstruction}\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.2 A & 59 & memory map, vector register \\ \hline
\end{tabular}
\vspace{2mm}

int64 write\_call\_stack(v1, r2, r3)
\vspace{2mm}

Write a vector register to the internal call stack. This instruction is used for restoring the internal call stack.
Privileged instruction.
\vspace{2mm}

\subsubsection{write\_spec}
\label{table:writeSpecInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B & 33 & g.p. register, special register \\ \hline
\end{tabular}
\vspace{2mm}

Write special register. See read\_spec instruction page \pageref{table:readSpecInstruction} for details.

\subsubsection{write\_sys}
\label{table:writeSysInstruction}
\begin{tabular}{|p{12mm}|p{12mm}|p{110mm}|}
\hline
\bfseries format & \bfseries opcode & \bfseries operands \\ \hline
1.8 B & 39 & g.p. register, system register \\ \hline
\end{tabular}
\vspace{2mm}

Write system register. Details are not defined yet. This instruction is privileged.
\vspace{2mm}


\section{Common operations that have no dedicated instruction}
This section discusses some common operations that are not implemented as single instructions, and how to code these operations in software.

\subsubsection{Change sign}
For integer operands, do a reverse subtract from zero. For floating point operands, use the toggle\_bit instruction on the sign bit.

\subsubsection{Not}
To invert all bits in an integer, do an XOR with -1. To invert a Boolean, do an XOR with 1.

\subsubsection{Rotate through carry}
Rotates through carry are rarely used, and common implementations can be very inefficient. A left rotate through carry can be replaced by an add\_c with the same register in both source operands.

\subsubsection{Push and pop registers}
\label{pushPop}
There are no push and pop instructions, but pseudo-instructions named push and pop are available
for saving and restoring registers on the stack. For example, pushing and popping a general purpose register r1 is implemented as follows.

\begin{lstlisting}[frame=single]
   // push (r1)
   int64 sp -= 8
   int64 [sp] = r1
   // pop (r1)
   int64 r1 = [sp]
   int64 sp += 8
\end{lstlisting}

Vector registers can be saved with the sub\_cps and save\_cp instructions and restored with 
the restore\_cp and add\_cps instructions. For example, pushing and popping a vector register v1 is implemented as follows.

\begin{lstlisting}[frame=single]
   // push (v1)
   int64 sp = sub_cps(sp, v1)
   [sp] = save_cp(v1)
   // pop (v1)      
   v1 = restore_cp([sp])
   int64 sp = add_cps(sp, v1)
\end{lstlisting} 

See page \pageref{table:saveCpInstruction} for details about these instructions
\vspace{2mm}


\subsubsection{Save and restore all registers}
The registers need to be saved and restored at task switches. There are no instructions to save all registers because we do not want complex instructions. The saving and restoring of registers is described under push and pop on page \pageref{pushPop}.
\vspace{2mm}

\subsubsection{Horizontal vector add} \label{horizontalVectorAdd}
See example \ref{exampleHorizontalAdd}.
\vspace{2mm}

\section{Unused instructions} \label{unusedInstructions}
Unused instructions and opcodes can be divided into three types:

\begin{enumerate}
\item The opcode is reserved for future use. Attempts to execute it will trigger a trap (synchronous interrupt) which can be used for generating an error message or for emulating instructions that are not supported.
\item The opcode is guaranteed to generate a trap, not only in the present version, but also in all future versions. This can be used as a filler in unused parts of the memory or for indicating unrecoverable errors. It can also be used for emulating user-specific instructions.
\item The error is ignored and does not trigger a trap. It can be used for future extensions that improve performance or functionality, but which can be safely ignored when not supported.
\end{enumerate}

All three types are implemented, where type 1 is the most common.
\vspace{2mm}

Nop instructions with nonzero values in unused fields are type 3. These instructions are ignored.
\vspace{2mm}

Prefetch and fence instructions with no memory operand, with nonzero values in unused fields, or with undefined values in IM3 are type 3. These instructions are ignored.
\vspace{2mm}

Unused bits in masks and numeric control register are type 3. These bits are ignored.
\vspace{2mm}

Trap instructions and conditional trap instructions with nonzero values in unused fields or undefined values in any field are type 2. These instructions are guaranteed to generate a trap. A special version of the trap instruction is intended as filler in unused or inaccessible parts of code memory.
\vspace{2mm}

The undef instruction is type 2. It is guaranteed to generate a trap in all systems. It can be used for testing purposes and emulation.
\vspace{2mm}

The userdef\_\_ instructions are type 1. These instructions are reserved for user-defined and application-specific purposes.
\vspace{2mm}

Instructions with erroneous coding should preferably behave as type 1. This includes instruction codes with nonzero values in unused fields, operand types not supported, or any other bit pattern with no defined meaning in any field. Type 3 behavior may alternatively be allowed in these cases. If so, the instruction should behave as if it were coded correctly.
\vspace{2mm}

All other opcodes not explicitly defined are type 1. These may be used for future instructions.
\vspace{2mm}

Small systems with no operating system and no trap support should define alternative behavior.

 
\end{document}
